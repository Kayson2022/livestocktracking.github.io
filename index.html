<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Investment App</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ’°</text></svg>">
    <!-- Third-party Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        /* --- CSS variables for theming --- */
        :root {
            --bg-color: #F3F4F6;
            --bg-gradient: linear-gradient(to bottom right, #f0f2f8, #e6e8f2);
            --card-bg-color: #ffffff;
            --text-color-primary: #111827;
            --text-color-secondary: #6B7280;
            --border-color: #E5E7EB; /* Solid light gray */
            --shadow-color: rgba(0, 0, 0, 0.05);
            --header-text-color: #111827;
            --input-bg-color: #ffffff;
            --input-border-color: #D1D5DB;
            --positive-color: #16A34A;
            --negative-color: #DC2626;
            --accent-color-1: #6D28D9;
            --accent-color-2: #8B5CF6;
            --card-bg-hover-color: #E9D5FF;
            --scan-bg-color: #6D28D9; /* Primary color for scan bar */
        }
        [data-theme="dark"] {
            --bg-color: #111827;
            --bg-gradient: linear-gradient(to bottom right, #1f2937, #111827);
            --card-bg-color: #1F2937;
            --text-color-primary: #F9FAFB;
            --text-color-secondary: #9CA3AF;
            --border-color: #374151; /* Solid dark gray */
            --shadow-color: rgba(0, 0, 0, 0.25);
            --header-text-color: #F9FAFB;
            --input-bg-color: #374151;
            --input-border-color: #4B5563;
            --card-bg-hover-color: #4C1D95;
            --scan-bg-color: #8B5CF6; /* Lighter primary color for dark theme */
        }
        [data-theme="dark"] .investment-item {
            background: var(--card-bg-color);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-gradient);
            min-height: 100vh;
            color: var(--text-color-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; margin-bottom: 30px; color: var(--header-text-color); }
        .header-top-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            min-height: 40px;
        }
        .header-left, .header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .header h1 { font-size: 2.5em; font-weight: 700; margin-bottom: 10px; }
        #userNameDisplay { color: var(--text-color-primary); }
        .data-status { background: rgba(255, 255, 255, 0.2); padding: 8px 12px; border-radius: 20px; font-size: 0.8em; color: var(--text-color-primary); backdrop-filter: blur(10px); white-space: nowrap; transition: background-color 0.3s ease; border: 1px solid var(--border-color); }
        .data-status.saved { background: rgba(22, 163, 74, 0.2); border-color: rgba(22, 163, 74, 0.5); }
        .data-status.loading { background: rgba(255, 193, 7, 0.2); border-color: rgba(255, 193, 7, 0.5); }
        .data-status.error { background: rgba(220, 38, 38, 0.2); border-color: rgba(220, 38, 38, 0.5); }
        .header-icon {
            background: var(--card-bg-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: 1px solid var(--border-color);
            font-size: 1.2em;
            color: var(--text-color-secondary);
            box-shadow: 0 2px 4px var(--shadow-color);
        }
        .visibility-toggle { font-size: 1.5em; }
        .settings-toggle { font-size: 1.4em; }

        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .stat-card { background: var(--card-bg-color); padding: 25px 15px; border-radius: 15px; text-align: center; box-shadow: 0 4px 10px var(--shadow-color); border: 1px solid var(--border-color); transition: transform 0.3s ease, box-shadow 0.3s ease; }
        .stat-card:hover { transform: translateY(-8px); box-shadow: 0 8px 20px var(--shadow-color); }
        .stat-value { font-size: 1.5em; font-weight: 700; margin-bottom: 5px; white-space: nowrap; }
        .stat-label { color: var(--text-color-secondary); font-size: 0.9em; font-weight: 500; }
        .charts-section { display: grid; grid-template-columns: 1fr; gap: 30px; margin-bottom: 30px; }
        .pie-charts-container { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; }
        .chart-container { background: var(--card-bg-color); padding: 25px; border-radius: 15px; box-shadow: 0 4px 10px var(--shadow-color); border: 1px solid var(--border-color); }
        .chart-container h3 { text-align: center; margin-bottom: 15px; color: var(--text-color-primary); font-weight: 600; }
        .chart-wrapper { position: relative; height: 300px; }
        .chart-filters { display: flex; justify-content: center; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;}
        .chart-filter-btn { background: var(--bg-color); border: 1px solid var(--border-color); color: var(--text-color-secondary); padding: 6px 12px; border-radius: 20px; cursor: pointer; transition: all 0.2s ease; font-size: 0.8em; font-weight: 500; }
        .chart-filter-btn:hover { background: #e5e7eb; }
        .chart-filter-btn.active { background: var(--accent-color-1); color: white; border-color: var(--accent-color-1); }
        .main-content { display: grid; grid-template-columns: 1fr 2fr; gap: 30px; margin-bottom: 30px; }
        .card-panel { background: var(--card-bg-color); padding: 25px; border-radius: 15px; box-shadow: 0 4px 10px var(--shadow-color); border: 1px solid var(--border-color); }
        .add-investment.card-panel { background-color: #F5F3FF; }
        .investments-list.card-panel { background-color: transparent; box-shadow: none; border: none; padding: 0; }
        .card-panel h2 { margin-bottom: 20px; color: var(--text-color-primary); font-weight: 600; }
        .form-group { position: relative; margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; font-weight: 600; color: var(--text-color-secondary); }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 12px; border: 1px solid var(--input-border-color); border-radius: 8px; font-size: 16px; font-family: 'Inter', sans-serif; background-color: var(--input-bg-color); color: var(--text-color-primary); transition: border-color 0.3s ease; }
        .form-group input:focus, .form-group select:focus, .form-group textarea:focus { outline: none; border-color: var(--accent-color-1); box-shadow: 0 0 0 2px rgba(109, 40, 217, 0.2); }
        #userNameInput { background-color: var(--input-bg-color) !important; border-color: var(--input-border-color) !important; color: var(--text-color-primary) !important; }
        #symbolValidationStatus { position: absolute; right: 10px; top: 38px; font-size: 1.2em; }
        .btn { background: linear-gradient(45deg, var(--accent-color-1), var(--accent-color-2)); color: white; padding: 12px 24px; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 600; transition: all 0.3s ease; width: 100%; margin: 2px; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .btn:disabled { background: #9CA3AF; cursor: not-allowed; transform: none; box-shadow: none; }
        .btn-danger { background: #EF4444; }
        .btn-danger:hover { background: #DC2626; }
        .btn-edit { background: #FBBF24; }
        .btn-edit:hover { background: #F59E0B; }
        .btn-secondary { background: linear-gradient(45deg, #8B5CF6, #7C3AED); }
        .investment-item { background: #F9FAFB; border-radius: 10px; margin-bottom: 15px; overflow: hidden; transition: all 0.3s ease; border: 1px solid var(--border-color); }
        .investment-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px var(--shadow-color);
            background-color: var(--card-bg-hover-color);
        }
        .investment-header { display: flex; justify-content: space-between; align-items: center; padding: 20px; }
        .investment-header-info { text-align: left; }
        .investment-header-actions .btn { padding: 6px 12px; font-size: 14px; width: auto; margin-left: 10px;}
        .investment-symbol { font-size: 1.2em; font-weight: 700; color: var(--text-color-primary); }
        .detail-value { font-weight: 600; color: var(--text-color-primary); }
        .stat-value.positive, .detail-value.positive { color: var(--positive-color); }
        .stat-value.negative, .detail-value.negative { color: var(--negative-color); }
        .detail-label { font-size: 0.9em; color: var(--text-color-secondary); margin-bottom: 2px; font-weight: 500; }
        .account-badge { padding: 4px 8px; border-radius: 12px; font-size: 0.75em; font-weight: 600; color: white; margin-left: 10px; }
        .account-regular { background: #3498db; } .account-roth { background: #e74c3c; } .account-401k { background: #f39c12; } .account-529 { background: #9b59b6; } .account-yahoo { background: #20c997; }
        .investment-item:not(.consolidated) .investment-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 15px;
            padding: 0 20px 20px 20px;
        }
        .detail-item { text-align: center; }
        .empty-state { text-align: center; padding: 40px; color: var(--text-color-secondary); }
        #clearAllDataBtn { background: linear-gradient(45deg, #e74c3c, #c0392b); }
        .investment-group { margin-bottom: 15px; border-radius: 10px; overflow: hidden; }
        .investment-group-header { background: var(--card-bg-color); padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px var(--shadow-color); margin-bottom: 0; display: flex; justify-content: space-between; align-items: center; cursor: pointer; transition: all 0.2s ease; border: 1px solid var(--border-color); }
        .investment-group-header[data-group-type="Regular Brokerage"] { border-left: 4px solid #3498db; }
        .investment-group-header[data-group-type="Roth IRA"] { border-left: 4px solid #e74c3c; }
        .investment-group-header[data-group-type="401(k)"] { border-left: 4px solid #f39c12; }
        .investment-group-header[data-group-type="529 College Saving"] { border-left: 4px solid #9b59b6; }
        .investment-group-header[data-group-type="Yahoo Finance"] { border-left: 4px solid #20c997; }
        .investment-group-header:hover { transform: translateY(-2px); box-shadow: 0 4px 15px var(--shadow-color); }
        .group-summary { flex-grow: 1; } .group-title { font-size: 1.3em; font-weight: 700; color: var(--text-color-primary); margin-bottom: 5px; } .group-stats { display: flex; gap: 15px; font-size: 0.9em; flex-wrap: wrap; } .group-stat-item .detail-label { font-size: 0.75em; color: var(--text-color-secondary); } .group-stat-item .detail-value { font-weight: 600; font-size: 1.1em; color: var(--text-color-primary); } .group-stat-item .detail-value.positive { color: var(--positive-color); } .group-stat-item .detail-value.negative { color: var(--negative-color); }
        .toggle-icon { font-size: 1.5em; font-weight: bold; color: var(--accent-color-1); margin-left: 15px; transition: transform 0.2s ease; }
        .investment-group.expanded .toggle-icon { transform: rotate(90deg); }
        .investment-group-content { display: none; padding-top: 15px; background: transparent; }
        .investment-group.expanded .investment-group-content { display: block; }
        .refresh-button-container { text-align: right; margin-bottom: 20px; padding-right: 2px; }
        .controls-bar { display: flex; gap: 10px; margin-bottom: 20px; align-items: center; flex-wrap: wrap; }
        .controls-bar .form-group { margin-bottom: 0; flex-grow: 1; } .controls-bar label { margin-right: 10px; font-weight: 600; } .controls-bar select, .controls-bar input { width: auto; min-width: 180px; }
        /* MODAL STYLES */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: none; align-items: center; justify-content: center; z-index: 1000; backdrop-filter: blur(5px); }
        .modal-content { background: var(--card-bg-color); padding: 30px; border-radius: 15px; width: 90%; max-width: 500px; text-align: center; box-shadow: 0 10px 40px rgba(0,0,0,0.2); border: 1px solid var(--border-color); position: relative;}
        .modal-message { font-size: 1.1em; margin-bottom: 25px; color: var(--text-color-primary); line-height: 1.6; }
        .modal-buttons { display: flex; gap: 15px; justify-content: center; }
        .modal-buttons .btn { width: auto; padding: 12px 20px;}
        .modal-close-btn { position: absolute; top: 15px; right: 15px; background: none; border: none; font-size: 1.5em; cursor: pointer; color: var(--text-color-secondary); }
        .btn-confirm { background: linear-gradient(45deg, #27ae60, #2ecc71); }
        .btn-cancel { background: linear-gradient(45deg, #95a5a6, #7f8c8d); }
        #editTransactionModal .modal-content, #editHoldingModal .modal-content, #settingsModal .modal-content, #recurringPurchaseModal .modal-content, #activityLogModal .modal-content { text-align: left; }
        #editTransactionModal .form-group, #editHoldingModal .form-group, #settingsModal .form-group, #recurringPurchaseModal .form-group { margin-bottom: 12px; }
        #editHoldingModal .form-group small { color: var(--text-color-secondary); font-size: 0.8em; margin-top: 4px; display: block; }
        
        /* Consolidated Card Styles */
        .investment-header-summary { text-align: right; }
        .investment-item.consolidated .investment-details {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            padding: 0 20px 20px 20px;
        }
        .consolidated-summary, .consolidated-footer {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 10px 15px;
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }
        .summary-item {
            display: flex;
            justify-content: space-between;
            font-size: 0.95em;
            flex-wrap: wrap;
        }
        .summary-item span:first-child { color: var(--text-color-secondary); }
        .summary-item span:last-child { font-weight: 600; }
        .consolidated-footer .summary-item span:last-child { font-size: 1.1em; }
        .purchase-breakdown h4 {
            margin-bottom: 10px;
            font-weight: 600;
        }
        .purchase-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 8px;
            background-color: white;
            border: 1px solid var(--border-color);
        }
        [data-theme="dark"] .purchase-item { background-color: var(--input-bg-color); }
        .purchase-item-actions .btn {
            padding: 4px 8px;
            font-size: 12px;
            width: auto;
            margin-left: 5px;
            min-height: 28px;
        }
        /* Transaction History Styles */
        .transaction-history {
            padding: 0 20px 20px 20px;
            background-color: rgba(0,0,0,0.02);
        }
        .transaction-history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding-top: 15px;
            margin-top: 15px;
            border-top: 1px solid var(--border-color);
        }
        .transaction-history-header h4 { margin: 0; }
        .transaction-table-container { display: none; margin-top: 10px;}
        .transaction-history.expanded .transaction-table-container { display: block; }
        .transaction-history .toggle-icon { transition: transform 0.2s ease; }
        .transaction-history.expanded .toggle-icon { transform: rotate(90deg); }
        .transaction-table { width: 100%; border-collapse: collapse; }
        .transaction-table th, .transaction-table td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9em;
        }
        .transaction-table th {
            font-weight: 600;
            color: var(--text-color-secondary);
        }
        .transaction-actions .btn {
            padding: 4px 8px;
            font-size: 12px;
            width: auto;
            margin: 0 2px;
        }

        /* Recurring Purchases List */
        #recurring-purchases-list { margin-top: 20px; max-height: 200px; overflow-y: auto; }
        .recurring-item { display: flex; justify-content: space-between; align-items: center; padding: 10px; border-radius: 6px; margin-bottom: 8px; background-color: var(--bg-color); border: 1px solid var(--border-color); }
        .recurring-item-info { font-size: 0.9em; }
        .recurring-item-info strong { color: var(--accent-color-1); }
        .recurring-item-actions .btn-danger { padding: 4px 8px; font-size: 12px; }
        
        /* Activity Log Styles */
        #activity-log-list { font-size: 0.9em; }
        .log-group { margin-bottom: 15px; }
        .log-group h4 { padding-bottom: 5px; border-bottom: 1px solid var(--border-color); margin-bottom: 8px; }
        .log-entry { display: flex; margin-bottom: 5px; }
        .log-time { color: var(--text-color-secondary); min-width: 70px; }
        .log-message { }

        /* Tab Styles */
        .tabs-nav {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 20px;
        }
        .tab-link {
            padding: 10px 20px;
            cursor: pointer;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            font-size: 1.1em;
            font-weight: 600;
            color: var(--text-color-secondary);
            transition: all 0.2s ease;
        }
        .tab-link:hover {
            color: var(--text-color-primary);
        }
        .tab-link.active {
            color: var(--accent-color-1);
            border-bottom-color: var(--accent-color-1);
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        /* Privacy Mode */
        body.stats-hidden .stat-value,
        body.stats-hidden .detail-value {
            color: transparent !important;
            text-shadow: 0 0 8px var(--text-color-secondary);
            user-select: none;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }


        .countdown-timer {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 500;
            z-index: 1001;
            display: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            backdrop-filter: blur(5px);
        }

        /* --- NEW SCANNING MODAL STYLES --- */
        #syncingProgressModal .modal-content {
            max-width: 450px;
            padding: 20px;
        }

        #syncingProgressModal #progressContainer {
            margin-bottom: 25px;
            min-height: 100px;
        }

        #syncingProgressModal #progressMessage {
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--text-color-primary);
            text-align: center;
        }

        #syncingProgressModal #progressBar {
            width: 100%;
            height: 10px;
            background-color: var(--border-color);
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        #syncingProgressModal #progressBarFill {
            height: 100%;
            width: 0%;
            background-color: var(--accent-color-1);
            transition: width 0.3s ease;
        }
        
        #syncingProgressModal #summaryBox {
            background-color: var(--scan-bg-color);
            color: white;
            padding: 15px 20px;
            border-radius: 12px;
            font-size: 1.1em;
            font-weight: 600;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        #syncingProgressModal .green { color: var(--positive-color); }
        #syncingProgressModal .red { color: var(--negative-color); }
        #syncingProgressModal .green-icon { color: #2ecc71; }
        #syncingProgressModal .red-icon { color: #e74c3c; }


        @media (max-width: 768px) {
            .container { padding: 15px; } .main-content { grid-template-columns: 1fr; } .stats-grid { grid-template-columns: repeat(2, 1fr); } .investment-header { flex-direction: column; align-items: flex-start; gap: 10px; padding: 15px; } 
            .header-top-row { flex-wrap: wrap; justify-content: center; }
            .header-left, .header-right { flex-basis: 50%; }
            .header-left { justify-content: flex-start; }
            .header-right { justify-content: flex-end; }
            .data-status { order: -1; width: 100%; margin-bottom: 15px; text-align: center; }
            #auth-container { min-width: 0; }
            #user-info span, #signOutBtn { display: none; } /* Hide text on mobile for auth */

            .pie-charts-container { grid-template-columns: 1fr; }
            .refresh-button-container { text-align: center; }
            .refresh-button-container .btn { 
                width: 100%;
                display: block;
                margin-bottom: 10px;
            }
        }
        @media (max-width: 480px) {
            .stats-grid { grid-template-columns: 1fr; } #dataTransfer button { width: 100%; margin: 5px 0; } .controls-bar .form-group { width: 100%; }
        }
        @media (min-width: 992px) {
            .investment-item:not(.consolidated) .investment-details {
                grid-template-columns: repeat(4, 1fr);
            }
        }
        /* Styles for Auth and Collapse Button */
        #auth-container { display: flex; align-items: center; gap: 10px; }
        #user-info { display: flex; align-items: center; gap: 10px; background: var(--card-bg-color); padding: 5px 10px; border-radius: 20px; border: 1px solid var(--border-color); box-shadow: 0 2px 4px var(--shadow-color); }
        #user-info img { width: 30px; height: 30px; border-radius: 50%; }
        #user-info span { font-weight: 600; font-size: 0.9em; }
        #signOutBtn { width: auto; font-size: 0.8em; padding: 6px 12px; background: #e74c3c; }
        .collapse-group-btn {
            display: block;
            margin: 15px auto 0;
            padding: 8px 16px;
            font-size: 0.9em;
            width: auto;
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            color: var(--text-color-secondary);
        }
        .collapse-group-btn:hover { background: #e5e7eb; }
        [data-theme="dark"] .collapse-group-btn:hover { background: #374151; }
    </style>
</head>
<body>

    <script type="module">
        // Firebase App (the core Firebase SDK) is always required and must be listed first
        import { initializeApp, getApps } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        // Import getDoc for the new session logic
        import { getFirestore, doc, setDoc, onSnapshot, collection, writeBatch, getDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // --- GLOBAL APP STATE ---
        const FIRESTORE_DATA_DOC = 'portfolioData';
        const FIRESTORE_UI_STATE_DOC = 'uiState';
        const FIRESTORE_PRICE_CACHE_DOC = 'priceCache';
        const FIRESTORE_SESSION_DOC = 'sessionManagement'; // Document for session control

        const THEME_KEY = 'myPortfolioTheme_v4';
        const AUTO_REFRESH_STATE_KEY = 'myPortfolioAutoRefreshState_v4';
        const STATS_VISIBILITY_KEY = 'myPortfolioStatsVisibility_v4';
        const FINNHUB_API_KEY_STORAGE = 'myPortfolioFinnhubKey_v4';
        const ALPHA_VANTAGE_API_KEY_STORAGE = 'myPortfolioAlphaVantageKey_v4';
        const FMP_API_KEY_STORAGE = 'myPortfolioFmpKey_v4';
        const REFRESH_INTERVAL_KEY = 'myPortfolioRefreshInterval_v4';
        const CORS_PROXY = "https://corsproxy.io/?";

        // --- API & Fetching Configuration ---
        const API_THROTTLE_DELAY = 350; // ms to wait between API calls
        const CACHE_STALE_TIME_FAST = 300 * 1000; // 5 minutes for Stocks, ETFs
        const CACHE_STALE_TIME_SLOW = 12 * 60 * 60 * 1000; // 12 hours for Mutual Funds, etc.

        let FINNHUB_API_KEY = 'd316lc1r01qnu2r0opjgd316lc1r01qnu2r0opk0';
        let ALPHA_VANTAGE_API_KEY = '0ZPH51BZ2N5O9G8Q';
        let FMP_API_KEY = 'vOqUU3gDIDYWghK8m4ZlsVQwLDnhfYMS';
        const WATCHLIST_ACCOUNT_TYPE = 'Yahoo Finance';

        let firebaseApp, db, auth, userId;
        let unsubscribePortfolio, unsubscribeUiState, unsubscribePriceCache, unsubscribeSession; 

        let portfolioData = {
             username: '',
             transactions: [],
             recurringTransactions: [],
             activityLog: []
        };
        let uiState = {
            expandedGroups: {},
            expandedTransactions: {}
        };
        let priceCache = {};

        let totalRealizedGainLoss = 0;
        let isSymbolValidated = false;
        let accountChart, investmentChart, historicalChart, dividendChart;
        let isAddFormExpanded = false;
        let countdownIntervalId = null;
        let isAutoRefreshEnabled = true;
        let isStatsVisible = true;
        let autoRefreshIntervalSeconds = 300;
        let currentSort = 'default';
        let currentFilter = 'all';
        let currentSearchTerm = '';
        let activeChartFilter = 'All';
        let validationTimeout = null;
        let lastEditedField = 'shares';
        let userNameUpdateTimeout = null;
        let isInitialDataLoaded = false;
        let hasRecurringCheckRun = false;
        let activeTab = 'investments';
        let historicalPriceCache = {}; // Session cache for historical price data
        let isUpdatingDisplay = false;
        let isRefreshingPrices = false; // NEW: Flag to prevent concurrent refresh calls
        let scanCompleteTimeout = null; // NEW: Timer for auto-closing scan modal

        // --- INITIALIZATION ---
        
        window.addEventListener('DOMContentLoaded', startApp);

        async function startApp() {
            document.getElementById('transactionDate').valueAsDate = new Date();
            loadTheme();
            loadApiKeys();
            loadAutoRefreshInterval();
            loadAutoRefreshState();
            loadStatsVisibility();

             // --- FIXED: Added null checks before adding listeners ---
            const sortOptionsEl = document.getElementById('sortOptions');
            if (sortOptionsEl) sortOptionsEl.addEventListener('change', e => { currentSort = e.target.value; updateDisplay(); });
            else console.error("Element with ID 'sortOptions' not found!");

            const filterPlatformEl = document.getElementById('filterPlatform');
            if (filterPlatformEl) filterPlatformEl.addEventListener('change', e => { currentFilter = e.target.value; updateDisplay(); });
             else console.error("Element with ID 'filterPlatform' not found!");

            const searchInputEl = document.getElementById('searchInput');
            if (searchInputEl) searchInputEl.addEventListener('input', e => { currentSearchTerm = e.target.value; updateDisplay(); });
             else console.error("Element with ID 'searchInput' not found!");

            const csvFileInputEl = document.getElementById('csvFileInput');
            if (csvFileInputEl) csvFileInputEl.addEventListener('change', handleCsvImport);
             else console.error("Element with ID 'csvFileInput' not found!");

            const userNameInputEl = document.getElementById('userNameInput');
            if (userNameInputEl) userNameInputEl.addEventListener('input', debouncedUpdateUserName); 
             else console.error("Element with ID 'userNameInput' not found!");

            const signInBtnEl = document.getElementById('signInBtn');
            if (signInBtnEl) signInBtnEl.addEventListener('click', signInWithGoogle);
             else console.error("Element with ID 'signInBtn' not found!");

            const signOutBtnEl = document.getElementById('signOutBtn');
            if (signOutBtnEl) signOutBtnEl.addEventListener('click', signOutUser);
             else console.error("Element with ID 'signOutBtn' not found!");
             // --- END FIX ---

            await initializeFirebase();
        }

        async function initializeFirebase() {
            // --- IMPORTANT: PASTE YOUR FIREBASE CONFIGURATION HERE ---
            const firebaseConfig = {
                apiKey: "AIzaSyAFnNTpbZc1K8Z_CwEFgCBfdK_rW2-ZlRg",
  authDomain: "smart-retirement-tracker.firebaseapp.com",
  databaseURL: "https://smart-retirement-tracker-default-rtdb.firebaseio.com",
  projectId: "smart-retirement-tracker",
  storageBucket: "smart-retirement-tracker.appspot.com", // Note: I corrected a small typo here from your example, it should end with .appspot.com
  messagingSenderId: "798740254583",
  appId: "1:798740254583:web:5d0835f78daa7f86fa9b72",
  measurementId: "G-9PXK08TWR8"
            };
            // --- END OF CONFIGURATION ---

            // Check if the user has replaced the placeholder configuration
            if (firebaseConfig.apiKey === "YOUR_API_KEY" || !firebaseConfig.apiKey) {
                showConfirmationModal("Configuration Needed: Please edit the index.html file and replace the placeholder 'YOUR_API_KEY', etc., with your actual Firebase project configuration values.", null);
                return; // Stop execution to prevent Firebase errors
            }
            
            try {
                // Initialize Firebase only if it hasn't been already
                if (getApps().length === 0) {
                    firebaseApp = initializeApp(firebaseConfig);
                } else {
                    firebaseApp = getApps()[0];
                }
                db = getFirestore(firebaseApp);
                auth = getAuth(firebaseApp);

                onAuthStateChanged(auth, async (user) => {
                    const signInBtn = document.getElementById('signInBtn');
                    const userInfoDiv = document.getElementById('user-info');
                    isInitialDataLoaded = false; // Reset on auth change
                    
                    // Detach old session listener on any auth change
                    if (unsubscribeSession) unsubscribeSession();
                     sessionStorage.removeItem('myAppInvalidationToken'); // Clear local token on auth change
                    
                    // Stop auto-refresh and scanning if refreshing is in progress on auth change
                    isRefreshingPrices = false;
                    clearInterval(countdownIntervalId);
                    document.getElementById('countdown-timer').style.display = 'none';
                    closeScanningModal();

                    if (user && !user.isAnonymous) {
                        userId = user.uid;
                        signInBtn.style.display = 'none';
                        userInfoDiv.style.display = 'flex';
                        document.getElementById('userName').textContent = user.displayName || 'User';
                        document.getElementById('userPhoto').src = user.photoURL || 'https://placehold.co/30x30/6D28D9/FFFFFF?text=U';
                        
                        // --- INTEGRATED SESSION LOGIC ON LOGIN ---
                        // Fetch the current invalidation token and store it locally
                        try {
                            const userDocRef = doc(db, 'users', userId);
                            const portfolioColRef = collection(userDocRef, 'data');
                            const sessionDocRef = doc(portfolioColRef, FIRESTORE_SESSION_DOC);
                            const docSnap = await getDoc(sessionDocRef);
                            if (docSnap.exists() && docSnap.data().invalidationToken) {
                                sessionStorage.setItem('myAppInvalidationToken', docSnap.data().invalidationToken);
                                console.log('Stored existing invalidation token locally.');
                            } else {
                                console.log('No invalidation token found in Firestore for this user.');
                                // Optionally create one here if needed for initial setup,
                                // but letting the button create it is generally sufficient.
                            }
                        } catch (e) {
                            console.error("Error fetching initial invalidation token:", e);
                        }
                        // --- END INTEGRATED SESSION LOGIC ---

                        await setupFirestoreListeners(); // Setup listeners, including the session listener
                        updateDataStatus(true); // Call updateDataStatus here - FIXED
                    } else {
                        userId = user?.uid; // Keep anonymous ID if exists
                        signInBtn.style.display = 'block';
                        userInfoDiv.style.display = 'none';
                        
                        // Clear invalidation token on sign-out/anonymous
                        sessionStorage.removeItem('myAppInvalidationToken');

                        if (!user) {
                           await signInAnonymously(auth);
                        } else {
                           await setupFirestoreListeners(); // Setup listeners for anonymous user (session listener won't attach)
                        }
                    }
                });

            } catch (error) {
                console.error("Firebase initialization failed:", error);
                showConfirmationModal("Firebase connection failed. Please check your configuration in the code.", null);
            }
        }

        async function signInWithGoogle() {
            const provider = new GoogleAuthProvider();
            try {
                await signInWithPopup(auth, provider);
            } catch (error) {
                console.error("Google Sign-In Error:", error);
                showConfirmationModal(`Could not sign in with Google. Error: ${error.message}`, null);
            }
        }

        async function signOutUser() {
            try {
                 sessionStorage.removeItem('myAppInvalidationToken'); // Clear local token on sign out
                await signOut(auth);
                location.reload();
            } catch (error) {
                console.error("Sign Out Error:", error);
                showConfirmationModal(`Could not sign out. Error: ${error.message}`, null);
            }
        }

        // --- INTEGRATED: Sign out other devices using Invalidation Token ---
        async function signOutOtherDevices() {
            if (!userId || !auth.currentUser || auth.currentUser.isAnonymous) {
                showConfirmationModal("You must be signed in to use this feature.", null);
                return;
            }

            // 1. Generate a new, unique invalidation token
            const newInvalidationToken = crypto.randomUUID();
            
            // 2. IMPORTANT: Immediately save this new token to THIS device's session storage
            sessionStorage.setItem('myAppInvalidationToken', newInvalidationToken);
            console.log('Set new invalidation token locally:', newInvalidationToken);

            try {
                // 3. Save this new token to Firestore, overwriting the old one
                const userDocRef = doc(db, 'users', userId);
                const portfolioColRef = collection(userDocRef, 'data');
                const sessionDocRef = doc(portfolioColRef, FIRESTORE_SESSION_DOC);

                await setDoc(sessionDocRef, { invalidationToken: newInvalidationToken }, { merge: true }); // Use merge to avoid overwriting other potential fields
                
                showConfirmationModal("Sign-out signal sent to all other devices. This device remains active.", null);
                closeSettingsModal(); // Close modal if it was opened from there
            } catch (error) {
                console.error("Error sending sign-out signal:", error);
                showConfirmationModal(`An error occurred sending the sign-out signal: ${error.message}`, null);
            }
        }
        // --- END INTEGRATED FUNCTION ---

        async function setupFirestoreListeners() { 
            if (!userId) return;
            if (unsubscribePortfolio) unsubscribePortfolio();
            if (unsubscribeUiState) unsubscribeUiState();
            if (unsubscribePriceCache) unsubscribePriceCache();
            if (unsubscribeSession) unsubscribeSession(); // Detach old session listener

            const userDocRef = doc(db, 'users', userId);
            const portfolioColRef = collection(userDocRef, 'data');

            // --- Portfolio, UI State, Price Cache Listeners (Unchanged from uploaded file) ---
             const portfolioDocRef = doc(portfolioColRef, FIRESTORE_DATA_DOC);
            unsubscribePortfolio = onSnapshot(portfolioDocRef, async (docSnap) => {
                let needsSave = false;
                if (docSnap.exists()) {
                    portfolioData = docSnap.data();
                     // Backwards compatibility for new features
                    if (!portfolioData.recurringTransactions) {
                        portfolioData.recurringTransactions = [];
                        needsSave = true;
                    }
                    if (!portfolioData.activityLog) {
                        portfolioData.activityLog = [];
                        needsSave = true;
                    }
                } else {
                    portfolioData = { username: '', transactions: [], recurringTransactions: [], activityLog: [] };
                    needsSave = true;
                }
                
                if(cleanUpActivityLog()) {
                    needsSave = true;
                }

                if (!hasRecurringCheckRun) {
                    const processed = await checkAndProcessRecurringTransactions();
                    if(processed) needsSave = true;
                    hasRecurringCheckRun = true;
                }
                
                if (needsSave) {
                    await saveDataToFirestore();
                } 

                if (!isInitialDataLoaded) {
                    isInitialDataLoaded = true;
                    await updateDisplay();
                } else {
                    await updateDisplay(false); // Subsequent updates won't re-fetch historical data
                }

                if (isAutoRefreshEnabled) startAutoRefresh(); else updateAutoRefreshButton();
            }, (error) => console.error("Error listening to portfolio:", error));

            const uiStateDocRef = doc(portfolioColRef, FIRESTORE_UI_STATE_DOC);
            unsubscribeUiState = onSnapshot(uiStateDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    uiState = docSnap.data();
                }
            });

            const priceCacheDocRef = doc(portfolioColRef, FIRESTORE_PRICE_CACHE_DOC);
            unsubscribePriceCache = onSnapshot(priceCacheDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    priceCache = docSnap.data();
                }
            });
            // --- End Unchanged Listeners ---


            // --- INTEGRATED SESSION LISTENER (using Invalidation Token) ---
            // Only attach if user is signed in (not anonymous)
            if (auth.currentUser && !auth.currentUser.isAnonymous) {
                const sessionDocRef = doc(portfolioColRef, FIRESTORE_SESSION_DOC);
                
                unsubscribeSession = onSnapshot(sessionDocRef, (docSnap) => {
                    let tokenFromFirestore = null;
                    if (docSnap.exists() && docSnap.data()) {
                        tokenFromFirestore = docSnap.data().invalidationToken;
                    }

                    const localToken = sessionStorage.getItem('myAppInvalidationToken');

                    if (tokenFromFirestore) {
                         // Case 1: Firestore has a token, but this device doesn't (sync local)
                        if (!localToken) {
                            sessionStorage.setItem('myAppInvalidationToken', tokenFromFirestore);
                            console.log('Synced local invalidation token from Firestore on initial load:', tokenFromFirestore);
                        }
                        // Case 2: Tokens DON'T match (sign out this device)
                        else if (localToken !== tokenFromFirestore) {
                            console.warn("Invalidation token mismatch detected. Notifying user and signing out.");
                            if (unsubscribeSession) unsubscribeSession(); 
                            
                            showConfirmationModal("You have been signed out because the 'Sign Out Other Devices' feature was used elsewhere.", signOutUser);
                        }
                        // Case 3: Tokens match -> Do nothing.
                    }
                    // Case 4: No token in Firestore (clear local if exists)
                    else if (localToken) {
                        sessionStorage.removeItem('myAppInvalidationToken');
                        console.log('Removed local token as none exists in Firestore.');
                    }

                }, (error) => console.error("Error listening to session management:", error));
            }
            // --- END INTEGRATED SESSION LISTENER ---
        }

        // --- MODALS (Confirmation, Firebase Config, Edit, etc.) ---
        function showConfirmationModal(message, onConfirm, onCancel) {
            const modal = document.getElementById('confirmationModal');
            const messageEl = document.getElementById('modalMessage');
            const confirmBtn = document.getElementById('modalConfirmBtn');
            const cancelBtn = document.getElementById('modalCancelBtn');

            messageEl.textContent = message;
            modal.style.display = 'flex';

            // Clone and replace buttons to remove old event listeners
            const newConfirmBtn = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

            const newCancelBtn = cancelBtn.cloneNode(true);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

            // Configure buttons based on whether onConfirm is provided
            if (onConfirm) {
                newConfirmBtn.style.display = 'inline-block';
                 newConfirmBtn.textContent = 'Confirm';
                 newConfirmBtn.onclick = () => {
                     modal.style.display = 'none';
                     onConfirm(); // Execute the confirm callback
                 };

                if (onCancel) {
                     newCancelBtn.style.display = 'inline-block';
                     newCancelBtn.textContent = 'Cancel';
                     newCancelBtn.onclick = () => {
                         modal.style.display = 'none';
                         onCancel(); // Execute the cancel callback
                     };
                } else {
                     newConfirmBtn.textContent = 'OK';
                     newCancelBtn.style.display = 'none';
                }
            } else {
                newConfirmBtn.style.display = 'inline-block';
                newCancelBtn.style.display = 'none';
                newConfirmBtn.textContent = 'OK';
                newConfirmBtn.onclick = () => {
                    modal.style.display = 'none';
                };
            }
        }

        // --- NEW SCANNING MODAL FUNCTIONS ---
        function openScanningModal() {
            document.getElementById('syncingProgressModal').style.display = 'flex';
        }
        function closeScanningModal() {
            document.getElementById('syncingProgressModal').style.display = 'none';
            // Clear the auto-close timeout if it exists (user closed manually)
            if (scanCompleteTimeout) {
                clearTimeout(scanCompleteTimeout);
                scanCompleteTimeout = null;
            }
        }
        function updateScanningProgress(currentIndex, totalCount, currentSymbol, stage = 'refresh') {
            const progressEl = document.getElementById('progressMessage');
            const fillEl = document.getElementById('progressBarFill');
            const summaryEl = document.getElementById('summaryBox');
            summaryEl.innerHTML = ''; // Clear summary on progress

            if (stage === 'refresh') {
                progressEl.textContent = `Refreshing ${currentSymbol}... (${currentIndex}/${totalCount})`;
                fillEl.style.width = `${(currentIndex / totalCount) * 100}%`;
                // Ensure the progress modal is visible during the process
                document.getElementById('syncingProgressModal').style.display = 'flex';
            } else if (stage === 'complete') {
                 // Clear the progress bar when complete
                fillEl.style.width = '100%';
                progressEl.textContent = `Scan Complete!`;
                // The summary content will be set below in refreshAllPrices
            }
        }
        // --- END NEW SCANNING MODAL FUNCTIONS ---
        
        // --- Activity Log (Unchanged) ---
        function cleanUpActivityLog() {
            if (!portfolioData.activityLog) {
                return false;
            }
            const fifteenYearsAgo = new Date();
            fifteenYearsAgo.setFullYear(fifteenYearsAgo.getFullYear() - 15);
            const originalLength = portfolioData.activityLog.length;
            portfolioData.activityLog = portfolioData.activityLog.filter(log => new Date(log.date) > fifteenYearsAgo);
            
            const removedCount = originalLength - portfolioData.activityLog.length;
            if (removedCount > 0) {
                console.log(`Cleaned up ${removedCount} old log entries.`);
                return true; // Indicate that a change was made
            }
            return false;
        }
        
        function logActivity(message) {
            if (!portfolioData.activityLog) {
                portfolioData.activityLog = [];
            }
            
            const logEntry = {
                date: new Date().toISOString(),
                message: message
            };
            portfolioData.activityLog.unshift(logEntry); // Add to the beginning of the array
        }

        function openActivityLogModal() {
            renderActivityLog();
            document.getElementById('activityLogModal').style.display = 'flex';
        }

        function closeActivityLogModal() {
            document.getElementById('activityLogModal').style.display = 'none';
        }

        function renderActivityLog() {
            const listEl = document.getElementById('activity-log-list');
            listEl.innerHTML = '';
            const log = portfolioData.activityLog || [];

            if (log.length === 0) {
                listEl.innerHTML = '<p style="text-align: center; color: var(--text-color-secondary);">No recent activity.</p>';
                return;
            }

            const groupedByDate = log.reduce((acc, log) => {
                const date = new Date(log.date).toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' });
                if (!acc[date]) {
                    acc[date] = [];
                }
                acc[date].push(log);
                return acc;
            }, {});

            let html = '';
            const sortedDates = Object.keys(groupedByDate).sort((a, b) => new Date(b) - new Date(a));
            
            for (const date of sortedDates) {
                html += `<div class="log-group"><h4>${date}</h4>`;
                groupedByDate[date].forEach(log => {
                    const time = new Date(log.date).toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
                    html += `
                        <div class="log-entry">
                            <span class="log-time">${time}</span>
                            <span class="log-message">${log.message}</span>
                        </div>
                    `;
                });
                html += `</div>`;
            }
            listEl.innerHTML = html;
        }
        // --- End Activity Log ---


        // --- Recurring Transactions Logic (Unchanged) ---
        function openRecurringPurchaseModal() {
            renderRecurringPurchasesList();
            document.getElementById('recurringPurchaseModal').style.display = 'flex';
            document.getElementById('recurringStartDate').valueAsDate = new Date();
        }

        function closeRecurringPurchaseModal() {
            document.getElementById('recurringPurchaseModal').style.display = 'none';
        }

        async function saveRecurringPurchase() {
            const symbol = document.getElementById('recurringSymbol').value.trim().toUpperCase();
            if (!symbol) {
                showConfirmationModal("Symbol is required.", null);
                return;
            }
            if (symbol.length < 1 || symbol.length > 10 || symbol.includes(' ')) {
                showConfirmationModal(`"${symbol}" does not look like a valid stock symbol.`, null);
                return;
            }

            const newRecurring = {
                id: Date.now(),
                symbol: symbol,
                amount: parseFloat(document.getElementById('recurringAmount').value),
                frequency: document.getElementById('recurringFrequency').value,
                startDate: document.getElementById('recurringStartDate').value,
                accountType: document.getElementById('recurringAccountType').value,
                platform: document.getElementById('recurringPlatform').value,
                lastExecutionDate: null 
            };

            if (!newRecurring.amount || newRecurring.amount <= 0 || !newRecurring.startDate || !newRecurring.accountType || !newRecurring.platform) {
                showConfirmationModal("All fields are required and amount must be greater than zero.", null);
                return;
            }
            if (!portfolioData.recurringTransactions) {
                portfolioData.recurringTransactions = [];
            }
            portfolioData.recurringTransactions.push(newRecurring);
            logActivity(`Created new recurring purchase for ${newRecurring.symbol}.`);
            await saveDataToFirestore();
            renderRecurringPurchasesList();
            document.getElementById('recurringSymbol').value = '';
            document.getElementById('recurringAmount').value = '';
        }
        
        async function deleteRecurringPurchase(id) {
            const itemToDelete = portfolioData.recurringTransactions.find(rt => rt.id === id);
            portfolioData.recurringTransactions = portfolioData.recurringTransactions.filter(rt => rt.id !== id);
            if (itemToDelete) {
                logActivity(`Deleted recurring purchase rule for ${itemToDelete.symbol}.`);
            }
            await saveDataToFirestore();
            renderRecurringPurchasesList();
        }

        function renderRecurringPurchasesList() {
            const listEl = document.getElementById('recurring-purchases-list');
            listEl.innerHTML = '';
            const recurring = portfolioData.recurringTransactions || [];

            if (recurring.length === 0) {
                listEl.innerHTML = '<p style="text-align: center; color: var(--text-color-secondary);">No recurring purchases set up.</p>';
                return;
            }

            recurring.forEach(rt => {
                const itemEl = document.createElement('div');
                itemEl.className = 'recurring-item';
                itemEl.innerHTML = `
                    <div class="recurring-item-info">
                        Purchasing <strong>${formatCurrency(rt.amount)}</strong> of <strong>${rt.symbol}</strong> ${rt.frequency}, starting ${rt.startDate}.
                    </div>
                    <div class="recurring-item-actions">
                        <button class="btn btn-danger" onclick="deleteRecurringPurchase(${rt.id})">Delete</button>
                    </div>
                `;
                listEl.appendChild(itemEl);
            });
        }
        
        async function checkAndProcessRecurringTransactions() {
            if (!portfolioData.recurringTransactions || portfolioData.recurringTransactions.length === 0) {
                return false;
            }

            let didCreateTransactions = false;
            const today = new Date();
            today.setHours(0,0,0,0); 

            for (const rule of portfolioData.recurringTransactions) {
                const startDate = new Date(rule.startDate + 'T00:00:00'); 
                let nextDate = startDate;
                
                if (rule.lastExecutionDate) {
                    const lastDate = new Date(rule.lastExecutionDate + 'T00:00:00');
                    nextDate = new Date(lastDate);
                    if (rule.frequency === 'weekly') {
                        nextDate.setDate(nextDate.getDate() + 7);
                    } else if (rule.frequency === 'bi-weekly') {
                        nextDate.setDate(nextDate.getDate() + 14);
                    } else if (rule.frequency === 'monthly') {
                        nextDate.setMonth(nextDate.getMonth() + 1);
                    }
                }
                
                if (nextDate <= today) {
                    console.log(`Processing recurring purchase for ${rule.symbol}`);
                    const priceData = await fetchPrice({ symbol: rule.symbol, type: 'ETF' }); 
                    if (priceData && priceData.currentPrice > 0) {
                        const shares = rule.amount / priceData.currentPrice;

                        const newTransaction = {
                            id: Date.now() + Math.random(),
                            transactionType: 'BUY',
                            date: today.toISOString().split('T')[0],
                            symbol: rule.symbol,
                            name: priceCache[rule.symbol]?.name || rule.symbol, 
                            type: 'ETF', 
                            shares: shares,
                            price: priceData.currentPrice,
                            accountType: rule.accountType,
                            platform: rule.platform,
                            dividend: 0
                        };
                        
                        portfolioData.transactions.push(newTransaction);
                        rule.lastExecutionDate = today.toISOString().split('T')[0];
                        logActivity(`Auto-logged recurring purchase: ${formatCurrency(rule.amount)} of ${rule.symbol}.`);
                        didCreateTransactions = true;
                    } else {
                        console.warn(`Could not fetch price for recurring purchase of ${rule.symbol}. Skipping.`);
                        logActivity(`Failed to auto-log recurring purchase for ${rule.symbol} (price fetch failed).`);
                    }
                }
            }

            if (didCreateTransactions) {
                showConfirmationModal("One or more recurring purchases were automatically logged.", null);
            }
            return didCreateTransactions; 
        }
        // --- End Recurring Transactions ---


        // --- Core Data Calculation Logic (Unchanged) ---
        function calculateHoldingsAndCash() {
            const holdings = {};
            let realizedGains = 0;
            const sortedTransactions = [...(portfolioData.transactions || [])].sort((a, b) => new Date(a.date) - new Date(b.date) || a.id - b.id);
            const taxLots = {};

            sortedTransactions.forEach(t => {
                const shares = parseFloat(t.shares);
                const price = parseFloat(t.price);
                const type = t.transactionType.toUpperCase();
                const positionKey = `${t.symbol}|||${t.accountType}|||${t.platform}`;

                if (type === 'BUY') {
                    if (!t.symbol || isNaN(shares) || isNaN(price)) return;
                    if (!taxLots[positionKey]) taxLots[positionKey] = [];
                    taxLots[positionKey].push({ shares, price, date: t.date, transaction: t });
                } else if (type === 'SELL') {
                    if (!t.symbol || isNaN(shares) || isNaN(price)) return;
                    let sharesToSell = shares;
                    if (!taxLots[positionKey]) taxLots[positionKey] = [];

                    while (sharesToSell > 0 && taxLots[positionKey].length > 0) {
                        const lot = taxLots[positionKey][0];
                        const sharesFromLot = Math.min(sharesToSell, lot.shares);

                        if (t.accountType !== WATCHLIST_ACCOUNT_TYPE) {
                            realizedGains += sharesFromLot * (price - lot.price);
                        }

                        lot.shares -= sharesFromLot;
                        sharesToSell -= sharesFromLot;

                        if (lot.shares < 0.0001) {
                            taxLots[positionKey].shift();
                        }
                    }
                }
            });

            Object.entries(taxLots).forEach(([positionKey, lots]) => {
                if (lots.length > 0) {
                    let totalShares = 0;
                    let totalCost = 0;
                    lots.forEach(lot => {
                        totalShares += lot.shares;
                        totalCost += lot.shares * lot.price;
                    });

                    if (totalShares > 0.00001) {
                        const firstTransaction = lots[0].transaction;
                        const [symbol, accountType, platform] = positionKey.split('|||');
                        holdings[positionKey] = {
                            symbol: symbol,
                            name: firstTransaction.name,
                            type: firstTransaction.type,
                            accountType: accountType,
                            platform: platform,
                            dividend: firstTransaction.dividend,
                            totalShares: totalShares,
                            totalCost: totalCost,
                            averagePurchasePrice: totalCost / totalShares,
                            transactions: portfolioData.transactions.filter(t => t.symbol === symbol && t.accountType === accountType && t.platform === platform)
                        };
                    }
                }
            });

            totalRealizedGainLoss = realizedGains;

            const calculatedHoldings = Object.values(holdings).map(h => {
                const cachedInfo = priceCache[h.symbol] || {};
                
                if (isCashEquivalentType(h.type)) {
                    h.currentPrice = 1.0;
                    h.previousClosePrice = 1.0; 
                } else if (cachedInfo.manualPrice != null && cachedInfo.manualPrice >= 0) {
                    h.currentPrice = cachedInfo.manualPrice;
                    h.previousClosePrice = cachedInfo.manualPreviousClosePrice || null; 
                } else if (cachedInfo.currentPrice && cachedInfo.currentPrice > 0) {
                    h.currentPrice = cachedInfo.currentPrice;
                    h.previousClosePrice = cachedInfo.previousClosePrice || null;
                } else if (h.type === 'Manual' || h.type === 'Other') { 
                    h.currentPrice = null;
                    h.previousClosePrice = null;
                } else {
                    h.currentPrice = null;
                    h.previousClosePrice = null;
                }
                                
                return h;
            });
            return calculatedHoldings;
        }

        async function buildPortfolioHistoryFromTransactions() {
            const nonWatchlistTransactions = (portfolioData.transactions || []).filter(t => t.accountType !== WATCHLIST_ACCOUNT_TYPE);
            if (nonWatchlistTransactions.length === 0) return [];

            const sorted = [...nonWatchlistTransactions].sort((a, b) => new Date(a.date) - new Date(b.date) || a.id - b.id);
            if (sorted.length === 0) return [];
            
            const relevantTransactions = sorted.filter(t => t.symbol && !isCashEquivalentType(t.type) && t.type !== 'Manual');
            const allSymbols = [...new Set(relevantTransactions.map(t => t.symbol))];

            const symbolsToFetch = allSymbols.filter(s => historicalPriceCache[s] === undefined);
            
            if (symbolsToFetch.length > 0 && ALPHA_VANTAGE_API_KEY) {
                 const MAX_AV_HISTORICAL_CALLS = 10; 
                 const symbolsToFetchLimited = symbolsToFetch.slice(0, MAX_AV_HISTORICAL_CALLS);
                
                console.log(`Attempting to fetch historical data for ${symbolsToFetchLimited.length} of ${symbolsToFetch.length} symbols using Alpha Vantage...`);
                
                if (symbolsToFetch.length > MAX_AV_HISTORICAL_CALLS) {
                    console.warn(`NOTE: Skipped historical fetch for ${symbolsToFetch.length - MAX_AV_HISTORICAL_CALLS} symbols to conserve Alpha Vantage limit.`);
                }
                
                for (const symbol of symbolsToFetchLimited) {
                    await delay(API_THROTTLE_DELAY * 2.5); 
                    try {
                        const outputSize = 'compact'; 
                        const url = `${CORS_PROXY}https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol=${symbol}&outputsize=${outputSize}&apikey=${ALPHA_VANTAGE_API_KEY}`;
                        const response = await fetch(url);
                        const data = await response.json();
                        
                        if (data.Information || data.Note) {
                            console.warn(`Alpha Vantage API limit likely reached for historical fetch of ${symbol}.`);
                            historicalPriceCache[symbol] = {}; 
                        } else if (data['Time Series (Daily)']) {
                            historicalPriceCache[symbol] = data['Time Series (Daily)'];
                        } else {
                            console.warn(`No historical data returned for ${symbol}.`);
                            historicalPriceCache[symbol] = {}; 
                        }
                    } catch (e) {
                        console.error(`Network error fetching historical data for ${symbol}:`, e);
                        historicalPriceCache[symbol] = {}; 
                    }
                }
                
                symbolsToFetch.slice(MAX_AV_HISTORICAL_CALLS).forEach(s => {
                    historicalPriceCache[s] = {};
                });
            } else if (symbolsToFetch.length > 0 && !ALPHA_VANTAGE_API_KEY) {
                 console.warn("Alpha Vantage API key is missing. Cannot fetch historical data for chart.");
            }

            const dailySnapshots = {};
            const firstDate = new Date(sorted[0].date);
            const today = new Date();
            const lastKnownPrices = {};

            for (let d = new Date(firstDate); d <= today; d.setDate(d.getDate() + 1)) {
                const dateString = d.toISOString().split('T')[0];
                const transactionsUpToDate = sorted.filter(t => new Date(t.date) <= d);

                let dailyTotalValue = 0;
                const tempHoldings = {};

                transactionsUpToDate.forEach(t => {
                    const shares = parseFloat(t.shares) || 0;
                    const price = parseFloat(t.price) || 0;
                    const type = t.transactionType.toUpperCase();
                    if (!t.symbol) return;
                    const symbol = t.symbol.toUpperCase();

                    if (!tempHoldings[symbol]) tempHoldings[symbol] = { totalShares: 0, totalCost: 0, type: t.type };

                    if (type === 'BUY') {
                        tempHoldings[symbol].totalShares += shares;
                        tempHoldings[symbol].totalCost += shares * price;
                    } else if (type === 'SELL') {
                        if (tempHoldings[symbol].totalShares > 0) {
                            const avgCost = tempHoldings[symbol].totalCost / tempHoldings[symbol].totalShares;
                            tempHoldings[symbol].totalCost -= shares * avgCost;
                        }
                        tempHoldings[symbol].totalShares -= shares;
                    }
                });

                Object.entries(tempHoldings).forEach(([symbol, holding]) => {
                    if (holding.totalShares <= 0) return;

                    if (isCashEquivalentType(holding.type)) {
                        dailyTotalValue += holding.totalShares;
                        return;
                    }
                    
                    let priceForDate = lastKnownPrices[symbol]; 

                    const symbolHistory = historicalPriceCache[symbol];
                    if (symbolHistory && symbolHistory[dateString]) {
                        priceForDate = parseFloat(symbolHistory[dateString]['4. close']);
                    }
                    
                    if (priceForDate === undefined || priceForDate === null || priceForDate <= 0) {
                        if (dateString === today.toISOString().split('T')[0] && priceCache[symbol]?.currentPrice) {
                            priceForDate = priceCache[symbol].currentPrice;
                        } 
                        else if (priceCache[symbol]?.currentPrice) {
                            priceForDate = priceCache[symbol].currentPrice;
                        }
                        else if (holding.totalShares > 0) { 
                            priceForDate = (holding.totalCost / holding.totalShares) || 0;
                        } else {
                            priceForDate = 0;
                        }
                    }
                    
                    dailyTotalValue += holding.totalShares * priceForDate;
                    lastKnownPrices[symbol] = priceForDate; 
                });

                dailySnapshots[dateString] = dailyTotalValue;
            }

            return Object.entries(dailySnapshots).map(([date, value]) => ({ date, value }));
        }
        // --- End Core Data Logic ---

        // --- Data Persistence Functions (Unchanged) ---
        function getCleanObject(obj) {
            return JSON.parse(JSON.stringify(obj));
        }

        async function saveDataToFirestore() {
            if (!isInitialDataLoaded || !userId) {
                console.warn("Data not fully loaded yet. Save operation skipped.");
                return;
            }
            try {
                const userDocRef = doc(db, 'users', userId);
                const portfolioColRef = collection(userDocRef, 'data');
                const batch = writeBatch(db);

                batch.set(doc(portfolioColRef, FIRESTORE_DATA_DOC), getCleanObject(portfolioData));
                batch.set(doc(portfolioColRef, FIRESTORE_UI_STATE_DOC), getCleanObject(uiState));
                batch.set(doc(portfolioColRef, FIRESTORE_PRICE_CACHE_DOC), getCleanObject(priceCache));
                // Note: Session doc is saved separately by its own functions, not in this batch.

                await batch.commit();
                updateDataStatus(true);
            } catch(e) {
                console.error("Error saving to Firestore:", e);
                updateDataStatus('error', "Save Failed");
            }
        }

        async function clearAllData() {
            showConfirmationModal('Are you sure you want to clear ALL transaction data from the cloud? This cannot be undone.', async () => {
                if (!userId) return;

                portfolioData = { username: '', transactions: [], recurringTransactions: [], activityLog: [] };
                uiState = { expandedGroups: {}, expandedTransactions: {} };
                priceCache = {};

                const userDocRef = doc(db, 'users', userId);
                const portfolioColRef = collection(userDocRef, 'data');
                await setDoc(doc(portfolioColRef, FIRESTORE_DATA_DOC), portfolioData);
                await setDoc(doc(portfolioColRef, FIRESTORE_UI_STATE_DOC), uiState);
                await setDoc(doc(portfolioColRef, FIRESTORE_PRICE_CACHE_DOC), priceCache);
                
                // Also clear the invalidation token
                await setDoc(doc(portfolioColRef, FIRESTORE_SESSION_DOC), { invalidationToken: null }, { merge: true });
                sessionStorage.removeItem('myAppInvalidationToken'); // Clear local token too
                
                logActivity('Cleared all portfolio data.');
                await saveDataToFirestore(); // Save the final state with the log
                updateDisplay();
                updateDataStatus(false, "Data cleared");
            });
        }
        // --- End Data Persistence ---

        // --- API & Price Fetching ---
        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

        function loadApiKeys() {
            FINNHUB_API_KEY = localStorage.getItem(FINNHUB_API_KEY_STORAGE) || 'd316lc1r01qnu2r0opjgd316lc1r01qnu2r0opk0';
            ALPHA_VANTAGE_API_KEY = localStorage.getItem(ALPHA_VANTAGE_API_KEY_STORAGE) || '0ZPH51BZ2N5O9G8Q';
            FMP_API_KEY = localStorage.getItem(FMP_API_KEY_STORAGE) || 'vOqUU3gDIDYWghK8m4ZlsVQwLDnhfYMS';
        }

        function loadAutoRefreshInterval() {
            const storedInterval = localStorage.getItem(REFRESH_INTERVAL_KEY);
            autoRefreshIntervalSeconds = storedInterval ? parseInt(storedInterval, 10) : 300;
        }

        function saveSettings() {
            FINNHUB_API_KEY = document.getElementById('finnhubApiKeyInput').value.trim();
            ALPHA_VANTAGE_API_KEY = document.getElementById('alphaVantageApiKeyInput').value.trim();
            FMP_API_KEY = document.getElementById('fmpApiKeyInput').value.trim();
            let newInterval = parseInt(document.getElementById('autoRefreshIntervalInput').value.trim(), 10);

            if (isNaN(newInterval) || newInterval < 30) {
                showConfirmationModal("Invalid interval. Please enter a number that is 30 or greater.", null);
                return;
            }
            autoRefreshIntervalSeconds = newInterval;
            localStorage.setItem(FINNHUB_API_KEY_STORAGE, FINNHUB_API_KEY);
            localStorage.setItem(ALPHA_VANTAGE_API_KEY_STORAGE, ALPHA_VANTAGE_API_KEY);
            localStorage.setItem(FMP_API_KEY_STORAGE, FMP_API_KEY);
            localStorage.setItem(REFRESH_INTERVAL_KEY, autoRefreshIntervalSeconds);

            logActivity('Application settings saved.');
            saveDataToFirestore();

            showConfirmationModal("Settings have been saved successfully.", null);
            closeSettingsModal();

            stopAutoRefresh();
            startAutoRefresh();
        }

        async function fetchPrice(holding) {
            if (isCashEquivalentType(holding.type)) {
                return { currentPrice: 1.0, previousClosePrice: 1.0 };
            }

            const symbol = holding.symbol;
            const isMutualFund = holding.type === 'Mutual Fund' || (symbol && symbol.toUpperCase().endsWith('X'));
            
            console.log(`Fetching price for: ${symbol}, Type: ${holding.type}, IsMutualFund: ${isMutualFund}`);

            let priceData;

            if (isMutualFund) {
                // --- Mutual Fund Priority: FMP -> Alpha Vantage ---
                console.log(`Trying FMP for Mutual Fund ${symbol}`);
                priceData = await fetchPriceFromFMP(symbol);
                if (priceData && priceData.currentPrice > 0) {
                    console.log(`Price for ${symbol} found via FMP.`);
                    return priceData;
                }
                await delay(API_THROTTLE_DELAY);

                console.log(`FMP failed, trying Alpha Vantage for Mutual Fund ${symbol}`);
                priceData = await fetchPriceFromAlphaVantage(symbol);
                if (priceData && priceData.currentPrice > 0) {
                    console.log(`Price for ${symbol} found via Alpha Vantage (fallback).`);
                    return priceData;
                }
                await delay(API_THROTTLE_DELAY);

            } else {
                // --- Stock/ETF Priority: Finnhub -> FMP -> Alpha Vantage ---
                console.log(`Trying Finnhub for Stock/ETF ${symbol}`);
                priceData = await fetchPriceFromFinnhub(symbol); // THIS WAS CAUSING THE ERROR
                if (priceData && priceData.currentPrice > 0) {
                    console.log(`Price for ${symbol} found via Finnhub.`);
                    return priceData;
                }
                await delay(API_THROTTLE_DELAY);

                console.log(`Finnhub failed, trying FMP for Stock/ETF ${symbol}`);
                priceData = await fetchPriceFromFMP(symbol);
                if (priceData && priceData.currentPrice > 0) {
                    console.log(`Price for ${symbol} found via FMP.`);
                    return priceData;
                }
                await delay(API_THROTTLE_DELAY);

                console.log(`FMP failed, trying Alpha Vantage for Stock/ETF ${symbol}`);
                priceData = await fetchPriceFromAlphaVantage(symbol);
                if (priceData && priceData.currentPrice > 0) {
                    console.log(`Price for ${symbol} found via Alpha Vantage (last fallback).`);
                    return priceData;
                }
                await delay(API_THROTTLE_DELAY);
            }

            console.warn(`All price providers failed for symbol: ${symbol}`);
            return { currentPrice: null, previousClosePrice: null };
        }
        
        // --- ADDED MISSING HELPER FUNCTIONS ---
        async function fetchPriceFromFinnhub(symbol) {
            if (!FINNHUB_API_KEY) return { currentPrice: null, previousClosePrice: null };
            try {
                const url = `${CORS_PROXY}https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`;
                const r = await fetch(url);

                if (!r.ok) {
                    if (r.status === 403) {
                        console.log(`Finnhub fetch for ${symbol} was forbidden. This is expected for most mutual funds on the free plan. Trying next provider.`);
                    } else {
                        console.warn(`Finnhub API returned a non-OK status for ${symbol}: ${r.status}`);
                    }
                    return { currentPrice: null, previousClosePrice: null };
                }

                const d = await r.json();
                // Ensure 'c' (current) and 'pc' (previous close) are valid numbers
                const currentPrice = (d && typeof d.c === 'number' && d.c > 0) ? d.c : null;
                const previousClosePrice = (d && typeof d.pc === 'number' && d.pc > 0) ? d.pc : null;
                
                return { currentPrice, previousClosePrice };
            } catch (e) {
                console.error(`A network error occurred while fetching from Finnhub for ${symbol}:`, e);
                return { currentPrice: null, previousClosePrice: null };
            }
        }

        async function fetchPriceFromFMP(symbol) {
             if (!FMP_API_KEY) return { currentPrice: null, previousClosePrice: null };
             try {
                 const historyUrl = `${CORS_PROXY}https://financialmodelingprep.com/api/v3/historical-price-full/${symbol}?timeseries=2&apikey=${FMP_API_KEY}`;
                 const historyRes = await fetch(historyUrl);
                 
                 if (!historyRes.ok) {
                     console.warn(`FMP historical fetch failed for ${symbol}: ${historyRes.status}`);
                     return { currentPrice: null, previousClosePrice: null }; 
                 }

                 const historyData = await historyRes.json();
                 
                 if (historyData && historyData.historical && historyData.historical.length >= 2) {
                     const latestClose = historyData.historical[0].close;
                     const previousDayClose = historyData.historical[1].close;
                      // Validate that prices are numbers > 0
                     const currentPrice = (typeof latestClose === 'number' && latestClose > 0) ? latestClose : null;
                     const previousClosePrice = (typeof previousDayClose === 'number' && previousDayClose > 0) ? previousDayClose : null;
                     return { currentPrice, previousClosePrice };
                 } else {
                     console.warn(`FMP did not return sufficient historical data for ${symbol}.`);
                     return { currentPrice: null, previousClosePrice: null }; 
                 }
             } catch (e) {
                  console.error(`A network error occurred during the FMP fetch for ${symbol}:`, e);
                  return { currentPrice: null, previousClosePrice: null };
             }
        }

        async function fetchPriceFromAlphaVantage(symbol) {
            if (!ALPHA_VANTAGE_API_KEY) return { currentPrice: null, previousClosePrice: null };
            try {
                const url = `${CORS_PROXY}https://www.alphavantage.co/query?function=TIME_SERIES_DAILY_ADJUSTED&symbol=${symbol}&apikey=${ALPHA_VANTAGE_API_KEY}`;
                const r = await fetch(url);
                const d = await r.json();

                if (d.Information || d.Note) {
                   console.warn(`Alpha Vantage API limit reached for ${symbol}. Price not updated.`);
                   return { currentPrice: null, previousClosePrice: null };
                }

                const ts = d['Time Series (Daily)'];
                if (ts && Object.keys(ts).length >= 2) {
                    const sortedDates = Object.keys(ts).sort((a, b) => new Date(b) - new Date(a));
                    
                    const latestDate = sortedDates[0];
                    const previousDate = sortedDates[1];

                    const latestClose = parseFloat(ts[latestDate]['4. close']);
                    const previousDayClose = parseFloat(ts[previousDate]['4. close']);

                     // Validate that prices are numbers > 0
                    const currentPrice = (!isNaN(latestClose) && latestClose > 0) ? latestClose : null;
                    const previousClosePrice = (!isNaN(previousDayClose) && previousDayClose > 0) ? previousDayClose : null;

                    return { currentPrice, previousClosePrice };
                }
                console.warn(`Alpha Vantage did not return sufficient data for ${symbol}.`);
                return { currentPrice: null, previousClosePrice: null };
            } catch (e) {
                console.error(`Alpha Vantage fetch error for ${symbol}:`, e);
                return { currentPrice: null, previousClosePrice: null };
            }
        }
        // --- END ADDED HELPER FUNCTIONS ---


        // --- MODIFIED: refreshAllPrices to include detailed scanning progress ---
        async function refreshAllPrices(forceRefresh = false) {
            if (!isInitialDataLoaded || isRefreshingPrices) return;

            isRefreshingPrices = true;
            const refreshButton = document.querySelector('.refresh-button-container .btn:last-child');
            refreshButton.textContent = 'Scanning...';
            refreshButton.disabled = true;
            updateDataStatus('loading');
            
            openScanningModal();
            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('modalCloseBtn').style.display = 'none'; // Hide close button during scan

            const allHoldings = calculateHoldingsAndCash();
            const uniqueSymbols = [...new Set(allHoldings.map(h => h.symbol))].filter(s => {
                const holding = allHoldings.find(h => h.symbol === s);
                return holding && holding.type !== 'Manual' && !isCashEquivalentType(holding.type);
            });
            
            const symbolsToFetch = [];
            const now = Date.now();
            
            // 1. Determine which symbols need fetching
            for (const symbol of uniqueSymbols) {
                const holding = allHoldings.find(h => h.symbol === symbol);
                const isFastMoving = holding.type === 'Stock' || holding.type === 'ETF';
                const cached = priceCache[symbol];
                const staleTime = isFastMoving ? CACHE_STALE_TIME_FAST : CACHE_STALE_TIME_SLOW;

                // Check for manual prices or recent cache
                if (!forceRefresh && cached && cached.manualPrice != null) {
                    console.log(`Using manual override for ${symbol}`);
                    continue;
                }
                if (!forceRefresh && cached && (now - (cached.lastFetchTimestamp || 0) < staleTime)) {
                    console.log(`Using fresh cached price for ${symbol}`);
                    continue;
                }

                symbolsToFetch.push({ symbol, holding });
            }

            const totalCount = symbolsToFetch.length;
            let refreshedCount = 0;
            let gainedCount = 0;
            let lostCount = 0;
            let failedCount = 0;
            let priceCacheUpdated = false;

            // 2. Fetch prices and update progress
            for (const item of symbolsToFetch) {
                refreshedCount++;
                const symbol = item.symbol;
                
                // Track previous close value to determine G/L
                const previousPrice = priceCache[symbol]?.currentPrice;

                updateScanningProgress(refreshedCount, totalCount, symbol);
                
                await delay(API_THROTTLE_DELAY);
                const priceData = await fetchPrice(item.holding);
                
                if (priceData && priceData.currentPrice !== null) {
                    const newPrice = priceData.currentPrice;
                    if (!priceCache[symbol]) priceCache[symbol] = {};
                    
                    priceCache[symbol].currentPrice = newPrice;
                    priceCache[symbol].previousClosePrice = priceData.previousClosePrice;
                    priceCache[symbol].lastFetchTimestamp = Date.now();
                    priceCacheUpdated = true;
                    
                    // Calculate G/L based on the last known price *before* this refresh
                    if (previousPrice && newPrice !== previousPrice) {
                        if (newPrice > previousPrice) {
                            gainedCount++;
                        } else if (newPrice < previousPrice) {
                            lostCount++;
                        }
                    } else if (!previousPrice && newPrice > 0) {
                        // Consider it a gain if it was previously unknown but now has a price (simplification)
                        gainedCount++;
                    }

                } else {
                    failedCount++;
                }
            }
            
            // 3. Complete process and display summary
            updateScanningProgress(refreshedCount, totalCount, 'Complete', 'complete');
            document.getElementById('summaryBox').innerHTML = `
                Refreshed ${refreshedCount} stock(s).
                <span class="green-icon">ðŸŸ¢</span> ${gainedCount} gained,
                <span class="red-icon">ðŸ”»</span> ${lostCount} lost.
                Failed: ${failedCount}.
            `;

            document.getElementById('modalCloseBtn').style.display = 'inline-block'; // Show close button after scan

            // NEW: Automatically close the modal after 5 seconds
            scanCompleteTimeout = setTimeout(() => {
                closeScanningModal();
            }, 5000); // 5000 milliseconds = 5 seconds

            if (priceCacheUpdated) {
                logActivity(`Refreshed prices for ${refreshedCount} assets. ${gainedCount} gained, ${lostCount} lost, ${failedCount} failed.`);
                await saveDataToFirestore();
            } else {
                 updateDataStatus(true, "Refreshed"); // Force sync status update if no data was saved
            }
            
            await updateDisplay(); 
            
            // 4. Reset flags and buttons
            refreshButton.textContent = 'Refresh Now';
            refreshButton.disabled = false;
            isRefreshingPrices = false;
        }

        async function validateWithAlphaVantage(symbol) {
            const statusEl = document.getElementById('symbolValidationStatus');
            if (!ALPHA_VANTAGE_API_KEY) {
                statusEl.textContent = 'âš ï¸';
                statusEl.title = 'Alpha Vantage API Key is missing for mutual fund lookup.';
                isSymbolValidated = false;
                return;
            }
            // Set a default value before API call
            const typeInput = document.getElementById('type');
            if (typeInput) typeInput.value = 'Stock'; 
            
            try {
                const url = `${CORS_PROXY}https://www.alphavantage.co/query?function=SYMBOL_SEARCH&keywords=${symbol}&apikey=${ALPHA_VANTAGE_API_KEY}`;
                const response = await fetch(url);
                const data = await response.json();

                if (data.Information || data.Note) {
                    statusEl.textContent = 'âš ï¸';
                    statusEl.title = 'Alpha Vantage API limit reached (25/day). Please try again tomorrow or use a premium key.';
                    isSymbolValidated = false;
                    return;
                }

                const match = data.bestMatches?.find(item => item['1. symbol'] === symbol);
                if (match) {
                    statusEl.textContent = 'âœ…';
                    statusEl.title = `Validated: ${match['2. name']}`;
                    document.getElementById('name').value = match['2. name'];
                    if (match['3. type'] === 'Mutual Fund') {
                        document.getElementById('type').value = 'Mutual Fund';
                    } else if (match['3. type'] === 'ETF') {
                        document.getElementById('type').value = 'ETF';
                    }
                    isSymbolValidated = true;
                } else {
                    statusEl.textContent = 'âŒ';
                    statusEl.title = 'Symbol not found on Finnhub or Alpha Vantage.';
                    isSymbolValidated = false;
                }
            } catch (error) {
                console.error("Alpha Vantage validation error:", error);
                statusEl.textContent = 'âš ï¸';
                statusEl.title = 'API Error during Alpha Vantage validation.';
                isSymbolValidated = false;
            }
        }

        function validateSymbol() {
            clearTimeout(validationTimeout);
            validationTimeout = setTimeout(async () => {
                const symbol = document.getElementById('symbol').value.trim().toUpperCase();
                const statusEl = document.getElementById('symbolValidationStatus');
                const typeInput = document.getElementById('type');
                isSymbolValidated = false;
                
                // Always default the hidden field
                if (typeInput) typeInput.value = 'Stock';

                if (!symbol) {
                    statusEl.textContent = '';
                    statusEl.title = '';
                    return;
                }
                statusEl.textContent = '...';
                statusEl.title = 'Validating...';

                const mmRegex = /^[A-Z]{3,5}XX$/;
                if (mmRegex.test(symbol)) {
                    statusEl.textContent = 'âœ…';
                    if (typeInput) typeInput.value = 'Money Market';
                    isSymbolValidated = true;
                    return;
                }
                if (!FINNHUB_API_KEY) {
                    statusEl.textContent = 'âš ï¸';
                    statusEl.title = 'Finnhub API Key is missing.';
                    return;
                }

                try {
                    const url = `${CORS_PROXY}https://finnhub.io/api/v1/search?q=${symbol}&token=${FINNHUB_API_KEY}`;
                    const response = await fetch(url);

                    if (!response.ok) {
                        if (response.status === 429) {
                            statusEl.textContent = 'âš ï¸';
                            statusEl.title = 'Finnhub API limit reached. Please wait a moment and try again, or use a premium key.';
                        } else {
                            const errorText = await response.text();
                            console.error("CORS/Network Error:", errorText);
                            statusEl.textContent = 'âš ï¸';
                            statusEl.title = `Network Error: ${response.statusText}. The proxy service may be down.`;
                        }
                        isSymbolValidated = false;
                        return;
                    }

                    const data = await response.json();
                    const match = data.result?.find(item => item.symbol === symbol);
                    if (match) {
                        statusEl.textContent = 'âœ…';
                        statusEl.title = `Validated: ${match.description}`;
                        document.getElementById('name').value = match.description.split(' ').slice(0, 3).join(' ');
                       if (match.description.toUpperCase().includes('MONEY MARKET')) {
                            if (typeInput) typeInput.value = 'Money Market';
                        } else if (match.type === 'ETF') {
                             if (typeInput) typeInput.value = 'ETF';
                        }
                        isSymbolValidated = true;
                    } else {
                        await validateWithAlphaVantage(symbol);
                    }
                } catch (error) {
                    console.error("Symbol validation error:", error);
                    statusEl.textContent = 'âš ï¸';
                    statusEl.title = 'API Error during validation. Check the browser console for details.';
                    isSymbolValidated = false;
                }
            }, 750);
        }
        // --- End API & Price Fetching ---

        // --- Form Interaction Logic (Unchanged) ---
        function updateTransactionFields(editedField) {
            const sharesInput = document.getElementById('shares');
            const priceInput = document.getElementById('price');
            const amountInput = document.getElementById('totalAmount');

            if (editedField === 'shares' || editedField === 'price') {
                lastEditedField = 'shares';
            } else if (editedField === 'amount') {
                lastEditedField = 'amount';
            }

            const shares = parseFloat(sharesInput.value);
            const price = parseFloat(priceInput.value);
            const amount = parseFloat(amountInput.value);

            if (lastEditedField === 'shares') {
                if (!isNaN(shares) && !isNaN(price) && price > 0) {
                    amountInput.value = (shares * price).toFixed(2);
                } else if (sharesInput.value === '') {
                    amountInput.value = '';
                }
            } else {
               if (!isNaN(amount) && !isNaN(price) && price > 0) {
                    sharesInput.value = (amount / price).toFixed(8);
                } else if (amountInput.value === '') {
                    sharesInput.value = '';
                }
            }
        }

        function clearForm() {
            document.getElementById('symbol').value = '';
            document.getElementById('name').value = '';
            document.getElementById('shares').value = '';
            document.getElementById('price').value = '';
            document.getElementById('amount').value = '';
            document.getElementById('totalAmount').value = '';
            document.getElementById('symbolValidationStatus').textContent = '';
            document.getElementById('type').value = 'Stock'; // Reset hidden type field
        }

        async function toggleAddForm() {
            isAddFormExpanded = !isAddFormExpanded;
            document.getElementById('addFormContent').style.display = isAddFormExpanded ? 'block' : 'none';
            document.getElementById('addFormToggleIcon').innerHTML = isAddFormExpanded ? '&#9660;' : '&#9658;';
        }

        function handleAccountTypeChange() {
            const accountType = document.getElementById('accountType').value;
            const transactionTypeValue = document.getElementById('transactionType').value;
            const fundingGroup = document.getElementById('fundingSourceGroup');

            if (accountType === '529 College Saving' && transactionTypeValue === 'BUY') {
                populateFundingSources();
                fundingGroup.style.display = 'block';
            } else {
                fundingGroup.style.display = 'none';
            }
        }

        function populateFundingSources() {
            const fundingSelect = document.getElementById('fundingSource');
            fundingSelect.innerHTML = '';
            const allAccounts = [...new Set(portfolioData.transactions.map(t => t.accountType))];
            const fundableAccounts = allAccounts.filter(acc => acc === 'Regular Brokerage');

            if(fundableAccounts.length > 0) {
               fundableAccounts.forEach(acc => {
                    const option = document.createElement('option');
                    option.value = acc;
                    option.textContent = acc;
                    fundingSelect.appendChild(option);
                });
            } else {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'No Brokerage account to fund from';
                fundingSelect.appendChild(option);
            }
        }

        function toggleTransactionFields() {
            const type = document.getElementById('transactionType').value;
            const cashFields = document.querySelectorAll('.cash-field');
            const transactionFields = document.querySelectorAll('.transaction-field');
            const buySellFields = document.querySelectorAll('.buy-sell-field');

            if (type === 'DEPOSIT' || type === 'WITHDRAWAL') {
                cashFields.forEach(f => f.style.display = 'block');
                buySellFields.forEach(f => f.style.display = 'none');
                document.getElementById('symbol').parentElement.style.display = 'block';
                document.getElementById('name').parentElement.style.display = 'block';
            } else if (type === 'DIVIDEND') {
                cashFields.forEach(f => f.style.display = 'block');
                buySellFields.forEach(f => f.style.display = 'none');
                document.getElementById('symbol').parentElement.style.display = 'block';
                document.getElementById('name').parentElement.style.display = 'block';
            } else { // BUY or SELL
                cashFields.forEach(f => f.style.display = 'none');
                transactionFields.forEach(f => f.style.display = 'block');
            }
            handleAccountTypeChange();
        }
        // --- End Form Interaction ---

        // --- Transaction CRUD Operations (Unchanged) ---
        function logTransaction() {
            const transactionType = document.getElementById('transactionType').value;
            const accountType = document.getElementById('accountType').value;
            const symbol = document.getElementById('symbol').value.trim().toUpperCase();
            const type = document.getElementById('type').value; // Now this reads the hidden field

            if (!accountType || !document.getElementById('platform').value) {
                showConfirmationModal("Account Type and Platform are required for all transactions.", null);
                return;
            }
            if ((transactionType === 'BUY' || transactionType === 'SELL' || transactionType === 'DIVIDEND' || transactionType === 'DEPOSIT' || transactionType === 'WITHDRAWAL') && !symbol) {
                showConfirmationModal('Symbol is required for this transaction type.', null);
                return;
            }
            if (type !== 'Manual' && !isSymbolValidated && accountType !== '529 College Saving' && (transactionType === 'BUY' || transactionType === 'SELL' || transactionType === 'DIVIDEND')) {
                showConfirmationModal(
                    `Symbol "${symbol}" is not validated. This could be due to API limits or an untracked asset. Do you want to log this transaction anyway?`,
                    () => { 
                        const statusEl = document.getElementById('symbolValidationStatus');
                        statusEl.textContent = 'âœï¸';
                        statusEl.title = 'Manually added';
                        isSymbolValidated = true;
                        proceedWithTransactionLogging();
                    }
                );
            } else {
                proceedWithTransactionLogging();
            }
        }

        async function proceedWithTransactionLogging() {
            const transactionType = document.getElementById('transactionType').value;
            const accountType = document.getElementById('accountType').value;
            const platform = document.getElementById('platform').value;
            const type = document.getElementById('type').value;
            const currentHoldings = calculateHoldingsAndCash();
            const transactionsToAdd = [];
            let mainTransaction = {
                id: Date.now(),
                transactionType: transactionType,
                date: document.getElementById('transactionDate').value,
                accountType: accountType,
                platform: platform,
            };
            let logMessage = '';

            if (transactionType === 'DEPOSIT' || transactionType === 'WITHDRAWAL') {
                const amount = parseFloat(document.getElementById('amount').value);
                if (isNaN(amount) || amount <= 0) { showConfirmationModal("Please enter a valid amount.", null); return; }

                const symbol = document.getElementById('symbol').value.trim().toUpperCase();
                mainTransaction.transactionType = (transactionType === 'DEPOSIT') ? 'BUY' : 'SELL';
                mainTransaction.symbol = symbol;
                mainTransaction.name = document.getElementById('name').value.trim() || symbol;
                mainTransaction.shares = amount; 
                mainTransaction.price = 1;
                mainTransaction.type = 'CASH'; 
                transactionsToAdd.push(mainTransaction);
                logMessage = `Logged ${transactionType}: ${formatCurrency(amount)} for ${symbol}.`;
            } else { 
                const symbol = document.getElementById('symbol').value.trim().toUpperCase();
                const shares = parseFloat(document.getElementById('shares').value);
                const price = parseFloat(document.getElementById('price').value);
                const cost = shares * price;
                if ((transactionType === 'BUY' || transactionType === 'SELL') && (!symbol || isNaN(shares) || shares <= 0 || isNaN(price) || price < 0)) {
                    showConfirmationModal("Symbol, Shares, and Price must be valid positive numbers.", null); return;
                }

                if(transactionType === 'DIVIDEND') {
                     const amount = parseFloat(document.getElementById('amount').value);
                     if (isNaN(amount) || amount <= 0) { showConfirmationModal("Please enter a valid dividend amount.", null); return; }

                     const cashFund = currentHoldings.find(h => h.accountType === accountType && h.platform === platform && isCashEquivalentType(h.type));
                     if (cashFund) {
                         mainTransaction.transactionType = 'BUY';
                         mainTransaction.symbol = cashFund.symbol;
                         mainTransaction.name = `Dividend from ${document.getElementById('symbol').value.trim().toUpperCase()}`;
                         mainTransaction.shares = amount;
                         mainTransaction.price = 1;
                         mainTransaction.type = cashFund.type;
                         transactionsToAdd.push(mainTransaction);
                         logMessage = `Logged ${transactionType}: ${formatCurrency(amount)} from ${symbol}.`;
                     } else {
                         showConfirmationModal(`No cash/money market fund found in ${accountType} on ${platform} to deposit dividend. Please add a cash fund (e.g., SPAXX) first.`, null);
                         return;
                     }
                } else { // BUY or SELL
                    Object.assign(mainTransaction, {
                        symbol: symbol, name: document.getElementById('name').value.trim() || symbol, shares: shares, price: price,
                        dividend: parseFloat(document.getElementById('dividend').value) || 0, type: type
                    });
                    transactionsToAdd.push(mainTransaction);
                    logMessage = `Logged ${transactionType}: ${shares.toFixed(4)} shares of ${symbol} at ${formatCurrency(price)}.`;
                }

                const isMoneyMarket = isCashEquivalentType(type);
                const isRetirementOr529 = accountType === '401(k)' || accountType === '529 College Saving';
                if (transactionType === 'BUY' && !isMoneyMarket && !isRetirementOr529 && accountType !== WATCHLIST_ACCOUNT_TYPE) {
                    const fundingAccountType = accountType;
                    const fundingPlatform = platform;
                    const cashAndMoneyMarketHoldings = currentHoldings.filter(h =>
                         h.accountType === fundingAccountType &&
                         h.platform === fundingPlatform &&
                        isCashEquivalentType(h.type)
                    );
                    const availableCash = cashAndMoneyMarketHoldings.reduce((sum, h) => sum + (Number(h.totalShares) || 0), 0);

                    if (availableCash < cost) {
                        showConfirmationModal(`Transaction Failed: Insufficient buying power in ${fundingAccountType} on ${fundingPlatform}. This purchase costs ${formatCurrency(cost)}, but you only have ${formatCurrency(availableCash)} available. Please log a DEPOSIT transaction first.`, null);
                        return;
                    }

                    const sourceFund = cashAndMoneyMarketHoldings.sort((a,b) => b.totalShares - a.totalShares)[0];
                    if (sourceFund) {
                        transactionsToAdd.unshift({ 
                            id: Date.now() - 1,
                            transactionType: 'SELL', date: mainTransaction.date, accountType: fundingAccountType,
                            platform: sourceFund.platform, symbol: sourceFund.symbol, name: sourceFund.name, shares: cost, price: 1, type: sourceFund.type
                        });
                    }
                }
               if(transactionType === 'SELL' && !isMoneyMarket && !isRetirementOr529) {
                     const cashFund = currentHoldings.find(h => h.accountType === accountType && h.platform === platform && isCashEquivalentType(h.type));
                     if (cashFund) {
                         transactionsToAdd.push({
                             id: Date.now() + 1, transactionType: 'BUY', date: mainTransaction.date, accountType: accountType,
                             platform: cashFund.platform, symbol: cashFund.symbol, name: cashFund.name, shares: cost, price: 1, type: cashFund.type
                         });
                     }
                }
            }

            portfolioData.transactions.push(...transactionsToAdd);
            logActivity(logMessage);
            await saveDataToFirestore();
            clearForm();
        }

        async function removeTransaction(id) {
            showConfirmationModal('Are you sure you want to remove this transaction?', async () => {
                const transaction = portfolioData.transactions.find(t => t.id == id);
                portfolioData.transactions = portfolioData.transactions.filter(t => t.id != id);
                if (transaction) {
                    logActivity(`Removed transaction: ${transaction.transactionType} of ${transaction.symbol}.`);
                }
                await saveDataToFirestore();
            });
        }

        async function removeHolding(symbol, accountType, platform) {
            showConfirmationModal(`Are you sure you want to delete ${symbol} from ${accountType} - ${platform} and all its associated transactions? This cannot be undone.`, async () => {
                portfolioData.transactions = portfolioData.transactions.filter(t => !(t.symbol === symbol && t.accountType === accountType && t.platform === platform));
                logActivity(`Removed holding ${symbol} from ${accountType} - ${platform}.`);
                await saveDataToFirestore();
            });
        }
        // --- End Transaction CRUD ---

        // --- Group Toggle (Unchanged) ---
        async function toggleGroup(groupName, shouldScroll = false) {
            uiState.expandedGroups[groupName] = !uiState.expandedGroups[groupName];
            await saveDataToFirestore();
            updateDisplay(false); 
            if (shouldScroll) {
                setTimeout(() => {
                    const groupHeader = document.getElementById(`group-${groupName.replace(/\s+/g, '-')}`);
                    if (groupHeader) {
                        groupHeader.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                }, 100);
            }
        }
        // --- End Group Toggle ---

        // --- Settings Modal (Unchanged) ---
        function openSettingsModal() {
            document.getElementById('finnhubApiKeyInput').value = FINNHUB_API_KEY;
            document.getElementById('alphaVantageApiKeyInput').value = ALPHA_VANTAGE_API_KEY;
            document.getElementById('fmpApiKeyInput').value = FMP_API_KEY; 
            document.getElementById('autoRefreshIntervalInput').value = autoRefreshIntervalSeconds;
            document.getElementById('settingsModal').style.display = 'flex';
        }

        function closeSettingsModal() {
            document.getElementById('settingsModal').style.display = 'none';
        }
        // --- End Settings Modal ---

        // --- Calculation and Rendering Logic (Unchanged) ---
        function isCashEquivalentType(type) {
            if (!type) return false;
            const t = String(type).trim().toLowerCase();
            const normalized = t.replace(/[^a-z0-9]/g, '');
            const isCash = normalized === 'cash' || normalized === 'moneymarket' || normalized === 'mm' || t.includes('cash') || (t.includes('money') && t.includes('market'));
            return isCash;
        }

        function calculateOverallStats(portfolioHoldings) {
            let totalCostBasis = 0;
            let totalValue = 0;
            let totalCashValue = 0;
            let totalDailyGainLoss = 0;
            let estimatedAnnualIncome = 0;
            let bestPerformer = { symbol: 'N/A', gain: -Infinity };
            let worstPerformer = { symbol: 'N/A', gain: Infinity };

            const filteredHoldings = portfolioHoldings.filter(h => h.accountType !== WATCHLIST_ACCOUNT_TYPE);
            const validPricedHoldings = filteredHoldings.filter(h => h.currentPrice !== null && h.currentPrice > 0);

            validPricedHoldings.forEach(h => {
                const isCashEquivalent = isCashEquivalentType(h.type);
                const displayPrice = h.currentPrice; 
                const currentValue = (Number(h.totalShares) || 0) * displayPrice;
                totalValue += currentValue;

                if (isCashEquivalent) {
                    totalCashValue += currentValue;
                } else {
                    totalCostBasis += Number(h.totalCost) || 0;
                    estimatedAnnualIncome += (Number(h.dividend) || 0) * (Number(h.totalShares) || 0);

                    // --- MODIFIED G/L LOGIC ---
                    const isRetirementOr529 = h.accountType === '401(k)' || h.accountType === '529 College Saving';
                    const cachedInfo = priceCache[h.symbol] || {};
                    let canIncludeDailyGL = true; // Default to true

                    if (isRetirementOr529) {
                        // It's a 401k/529. It must have a manual price entry, and it must be fresh.
                        const manualTimestamp = cachedInfo.manualPriceEntryTimestamp || 0;
                        const twentyFourHoursAgo = Date.now() - (24 * 60 * 60 * 1000);
                        
                        if (manualTimestamp < twentyFourHoursAgo) {
                            // If timestamp is missing (0) or older than 24h, it's stale.
                            canIncludeDailyGL = false;
                        }
                    }

                    // Now, wrap the original G/L calculation in this check:
                    if (canIncludeDailyGL && h.previousClosePrice !== null && h.previousClosePrice > 0) {
                        totalDailyGainLoss += (currentValue - ((Number(h.totalShares) || 0) * h.previousClosePrice));
                    }
                    // --- END MODIFIED G/L LOGIC ---
                    
                    const unrealizedGain = currentValue - (Number(h.totalCost) || 0);
                    if (unrealizedGain > bestPerformer.gain) {
                        bestPerformer = { symbol: h.symbol, gain: unrealizedGain };
                    }
                    if (unrealizedGain < worstPerformer.gain) {
                        worstPerformer = { symbol: h.symbol, gain: unrealizedGain };
                    }
                }
            });

            const investedAssetsValue = validPricedHoldings
                .filter(h => !isCashEquivalentType(h.type))
                .reduce((sum, h) => {
                    return sum + ((Number(h.totalShares) || 0) * h.currentPrice);
                }, 0);

            const totalUnrealizedGainLoss = investedAssetsValue - totalCostBasis;

            return { totalCostBasis, totalValue, totalCashValue, totalUnrealizedGainLoss, totalDailyGainLoss, estimatedAnnualIncome, portfolioYieldOnCost: totalCostBasis > 0 ? estimatedAnnualIncome / totalCostBasis : 0, bestPerformer, worstPerformer };
        }

        function updateStats(stats) {
            document.getElementById('totalValue').textContent = formatCurrency(stats.totalValue);
            document.getElementById('totalInvested').textContent = formatCurrency(stats.totalCostBasis);
            document.getElementById('totalCashValue').textContent = formatCurrency(stats.totalCashValue);
            const unrealizedEl = document.getElementById('unrealizedGainLoss');
            unrealizedEl.textContent = formatCurrency(stats.totalUnrealizedGainLoss);
            unrealizedEl.className = 'stat-value ' + (stats.totalUnrealizedGainLoss >= 0 ? 'positive' : 'negative');
            const realizedEl = document.getElementById('realizedGainLoss');
            realizedEl.textContent = formatCurrency(totalRealizedGainLoss);
            realizedEl.className = 'stat-value ' + (totalRealizedGainLoss >= 0 ? 'positive' : 'negative');
            const todayEl = document.getElementById('todayPortfolioGainLoss');
            todayEl.textContent = formatCurrency(stats.totalDailyGainLoss);
            todayEl.className = 'stat-value ' + (stats.totalDailyGainLoss >= 0 ? 'positive' : 'negative');
            document.getElementById('estimatedAnnualIncome').textContent = formatCurrency(stats.estimatedAnnualIncome);
            document.getElementById('portfolioYieldOnCost').textContent = formatPercentage(stats.portfolioYieldOnCost);
            document.getElementById('bestPerformerValue').textContent = formatCurrency(stats.bestPerformer.gain);
            document.getElementById('bestPerformerSymbol').textContent = stats.bestPerformer.symbol;
            document.getElementById('bestPerformerValue').className = 'stat-value ' + (stats.bestPerformer.gain >= 0 ? 'positive' : 'negative');
            document.getElementById('worstPerformerValue').textContent = formatCurrency(stats.worstPerformer.gain);
            document.getElementById('worstPerformerSymbol').textContent = stats.worstPerformer.symbol;
            document.getElementById('worstPerformerValue').className = 'stat-value ' + (stats.worstPerformer.gain >= 0 ? 'positive' : 'negative');
        }

        function renderInvestments(holdings) {
            if (!holdings) return;
            const container = document.getElementById('investmentsList');
            container.innerHTML = '';

            let holdingsToRender = [...holdings];
            const searchTerm = currentSearchTerm.toLowerCase();

            if (searchTerm) {
                holdingsToRender = holdingsToRender.filter(h =>
                    h.symbol.toLowerCase().includes(searchTerm) || h.name.toLowerCase().includes(searchTerm)
                );
            }
            if (currentFilter !== 'all') {
                holdingsToRender = holdingsToRender.filter(h => h.platform === currentFilter);
            }

            const groupedByAccount = {};
            holdingsToRender.forEach(h => {
                if (!groupedByAccount[h.accountType]) groupedByAccount[h.accountType] = [];
                groupedByAccount[h.accountType].push(h);
            });

            const accountOrder = ['Regular Brokerage', 'Roth IRA', '401(k)', '529 College Saving', 'Yahoo Finance'];
            const sortedAccountTypes = Object.keys(groupedByAccount).sort((a,b) => {
                const indexA = accountOrder.indexOf(a);
                const indexB = accountOrder.indexOf(b);
                if (indexA === -1) return 1;
                if (indexB === -1) return -1;
                return indexA - indexB;
            });

            if (sortedAccountTypes.length === 0) {
                container.innerHTML = `<div class="empty-state">ðŸ“Š<p>No holdings found. Log a transaction or clear your filters.</p></div>`;
                return;
            }

            sortedAccountTypes.forEach(accountType => {
                container.innerHTML += renderInvestmentGroup(accountType, groupedByAccount[accountType]);
            });
        }

        function renderInvestmentGroup(groupName, holdings) {
            const isWatchlist = groupName === WATCHLIST_ACCOUNT_TYPE;
            const pricedHoldings = holdings.filter(h => h.currentPrice !== null && h.currentPrice > 0);
            const totalGroupValue = pricedHoldings.reduce((sum, h) => sum + (Number(h.totalShares) || 0) * h.currentPrice, 0);
            const investedHoldings = pricedHoldings.filter(h => !isCashEquivalentType(h.type));
            const totalGroupInvestedCostBasis = investedHoldings.reduce((sum, h) => sum + (Number(h.totalCost) || 0), 0);
            const investedValue = investedHoldings.reduce((sum, h) => sum + ((Number(h.totalShares) || 0) * h.currentPrice), 0);
            const totalGroupGainLoss = investedValue - totalGroupInvestedCostBasis; 
            const totalGroupReturnPercentage = totalGroupInvestedCostBasis > 0 ? (totalGroupGainLoss / totalGroupInvestedCostBasis) : 0;
            
            // --- MODIFIED G/L LOGIC ---
            let totalGroupDailyGainLoss = investedHoldings.reduce((sum, h) => {
                const isRetirementOr529 = h.accountType === '401(k)' || h.accountType === '529 College Saving';
                const cachedInfo = priceCache[h.symbol] || {};
                let canIncludeDailyGL = true;

                if (isRetirementOr529) {
                    const manualTimestamp = cachedInfo.manualPriceEntryTimestamp || 0;
                    const twentyFourHoursAgo = Date.now() - (24 * 60 * 60 * 1000);
                    if (manualTimestamp < twentyFourHoursAgo) {
                        canIncludeDailyGL = false;
                    }
                }

                if (canIncludeDailyGL && h.previousClosePrice !== null && h.previousClosePrice > 0) {
                    return sum + ((h.currentPrice - h.previousClosePrice) * (Number(h.totalShares) || 0));
                }
                return sum;
            }, 0);
            // --- END MODIFIED G/L LOGIC ---

            let groupStatsHtml = '';
            if (isWatchlist) {
                groupStatsHtml = `<div class="group-stat-item"><div class="detail-label">Tracking ${holdings.length} symbols</div></div>`;
            } else {
                groupStatsHtml = `
                    <div class="group-stat-item"><div class="detail-label">Value</div><div class="detail-value">${formatCurrency(totalGroupValue)}</div></div>
                    <div class="group-stat-item"><div class="detail-label">Cost Basis</div><div class="detail-value">${formatCurrency(totalGroupInvestedCostBasis)}</div></div>
                    <div class="group-stat-item"><div class="detail-label">G/L</div><div class="detail-value ${totalGroupGainLoss >= 0 ? 'positive' : 'negative'}">${formatCurrency(totalGroupGainLoss)}</div></div>
                    <div class="group-stat-item"><div class="detail-label">G/L %</div><div class="detail-value ${totalGroupGainLoss >= 0 ? 'positive' : 'negative'}">${formatPercentage(totalGroupReturnPercentage)}</div></div>
                    <div class="group-stat-item"><div class="detail-label">Today</div><div class="detail-value ${totalGroupDailyGainLoss >= 0 ? 'positive' : 'negative'}">${formatCurrency(totalGroupDailyGainLoss)}</div></div>
                `;
            }

            const holdingsBySymbol = {};
            holdings.forEach(h => {
                if (!holdingsBySymbol[h.symbol]) holdingsBySymbol[h.symbol] = [];
                holdingsBySymbol[h.symbol].push(h);
            });

            const sortedSymbols = Object.keys(holdingsBySymbol).sort((a, b) => {
                const holdingsA = holdingsBySymbol[a][0];
                const holdingsB = holdingsBySymbol[b][0];
                const isCashA = isCashEquivalentType(holdingsA.type);
                const isCashB = isCashEquivalentType(holdingsB.type);

                if (isCashA && !isCashB) return -1;
               if (!isCashA && isCashB) return 1;

                const valueA = holdingsBySymbol[a].reduce((sum, h) => sum + (h.totalShares * (h.currentPrice || 0)), 0);
                const valueB = holdingsBySymbol[b].reduce((sum, h) => sum + (h.totalShares * (h.currentPrice || 0)), 0);
                return valueB - valueA;
            });

            let contentHtml = '';
            sortedSymbols.forEach(symbol => {
                const symbolHoldings = holdingsBySymbol[symbol];
                if (isWatchlist || symbolHoldings.length === 1) {
                    contentHtml += renderIndividualHolding(symbolHoldings[0]);
                } else {
                    contentHtml += renderConsolidatedHolding(symbol, groupName, symbolHoldings);
                }
            });

            const isExpanded = !!uiState.expandedGroups[groupName];
            return `
                <div class="investment-group ${isExpanded ? 'expanded' : ''}" id="group-${groupName.replace(/\s+/g, '-')}" >
                    <div class="investment-group-header" data-group-type="${groupName}" onclick="toggleGroup('${groupName}')">
                        <div class="group-summary">
                            <div class="group-title">${groupName}</div>
                            <div class="group-stats">${groupStatsHtml}</div>
                        </div>
                        <span class="toggle-icon">${isExpanded ? '&#9660;' : '&#9658;'}</span>
                    </div>
                    <div class="investment-group-content">
                        ${contentHtml}
                        ${isExpanded && holdings.length > 3 ? `<button class="btn collapse-group-btn" onclick="event.stopPropagation(); toggleGroup('${groupName}', true)">Collapse Section</button>` : ''}
                    </div>
                </div>
            `;
        }

        function renderIndividualHolding(h) {
            const hasLivePrice = h.currentPrice !== null && h.currentPrice > 0;
            const displayPrice = h.currentPrice || h.averagePurchasePrice; 
            const currentValue = hasLivePrice ? (Number(h.totalShares) || 0) * h.currentPrice : (Number(h.totalShares) || 0) * (Number(h.averagePurchasePrice) || 0);
            const totalGainLoss = currentValue - h.totalCost;
            const totalReturnPercentage = h.totalCost > 0 ? (totalGainLoss / h.totalCost) : 0;
            const annualIncome = (Number(h.dividend) || 0) * (Number(h.totalShares) || 0);
            const yieldOnCost = h.totalCost > 0 ? (annualIncome / h.totalCost) : 0;
            const isWatchlist = h.accountType === WATCHLIST_ACCOUNT_TYPE;
            let todayGainLossAmount = 0;
            let todayGainLossPercentage = 0;

            if (hasLivePrice && !isCashEquivalentType(h.type) && h.previousClosePrice !== null && h.previousClosePrice > 0) {
                const previousCloseValue = h.previousClosePrice * (Number(h.totalShares) || 0);
                todayGainLossAmount = (h.currentPrice - h.previousClosePrice) * (Number(h.totalShares) || 0);
                todayGainLossPercentage = previousCloseValue > 0 ? (todayGainLossAmount / previousCloseValue) : 0;
            }
            let headerHtml = '';
            let detailsHtml = '';
            
            // --- MODIFIED G/L LOGIC (for display) ---
            const isRetirementOr529 = h.accountType === '401(k)' || h.accountType === '529 College Saving';
            const cachedInfo = priceCache[h.symbol] || {};
            let canIncludeDailyGL = true;
            if (isRetirementOr529) {
                const manualTimestamp = cachedInfo.manualPriceEntryTimestamp || 0;
                const twentyFourHoursAgo = Date.now() - (24 * 60 * 60 * 1000);
                if (manualTimestamp < twentyFourHoursAgo) {
                    canIncludeDailyGL = false;
                }
            }
            
            let todayGLLabelClass = todayGainLossAmount >= 0 ? 'positive' : 'negative';
            let todayGLAmountDisplay = hasLivePrice && canIncludeDailyGL ? formatCurrency(todayGainLossAmount) : (isRetirementOr529 ? '(Stale)' : '...');
            let todayGLPercentDisplay = hasLivePrice && canIncludeDailyGL ? formatPercentage(todayGainLossPercentage) : '...';

            if (isWatchlist) {
                 todayGLAmountDisplay = hasLivePrice ? formatCurrency(todayGainLossAmount) : '...';
                 todayGLPercentDisplay = hasLivePrice ? formatPercentage(todayGainLossPercentage) : '...';
                headerHtml = `
                        <div class="investment-header-info">
                            <div class="investment-symbol">${h.symbol}</div>
                            <div style="color: #666; font-size: 0.9em;">${h.name}</div>
                        </div>
                        <div class="investment-header-summary">
                            <div class="detail-value">${hasLivePrice ? formatCurrency(h.currentPrice) : '...'}</div>
                            <div class="detail-value ${todayGLLabelClass}">
                                ${hasLivePrice ? `${todayGLAmountDisplay} (${todayGLPercentDisplay})` : '...'}
                            </div>
                        </div>
                `;
            } else {
                headerHtml = `
                    <div class="investment-header-info">
                        <div class="investment-symbol">${h.symbol}<span class="account-badge ${getAccountBadgeClass(h.accountType)}">${h.platform}</span></div>
                        <div style="color: var(--text-color-secondary); font-size: 0.9em;">${h.name} â€¢ ${h.type}</div>
                    </div>
                    <div class="investment-header-actions">
                        <button class="btn btn-edit" onclick="event.stopPropagation(); openHoldingEditModal('${h.symbol}', '${h.accountType}', '${h.platform}')">Edit</button>
                        <button class="btn btn-danger" onclick="event.stopPropagation(); removeHolding('${h.symbol}', '${h.accountType}', '${h.platform}')">Remove</button>
                    </div>
                `;
                detailsHtml = `
                    <div class="detail-item"><div class="detail-label">Shares</div><div class="detail-value">${(Number(h.totalShares) || 0).toLocaleString(undefined, { maximumFractionDigits: 4 })}</div></div>
                    <div class="detail-item"><div class="detail-label">Avg. Cost</div><div class="detail-value">${formatCurrency(h.averagePurchasePrice)}</div></div>
                    <div class="detail-item"><div class="detail-label">Current Price</div><div class="detail-value">${hasLivePrice ? formatCurrency(h.currentPrice) : '...'}</div></div>
                    <div class="detail-item"><div class="detail-label">Cost Basis</div><div class="detail-value">${formatCurrency(h.totalCost)}</div></div>
                    <div class="detail-item"><div class="detail-label">Market Value</div><div class="detail-value">${hasLivePrice ? formatCurrency(currentValue) : '...'}</div></div>
                    <div class="detail-item"><div class="detail-label">Unrealized G/L</div><div class="detail-value ${totalGainLoss >= 0 ? 'positive' : 'negative'}">${hasLivePrice ? formatCurrency(totalGainLoss) : '...'}</div></div>
                    <div class="detail-item"><div class="detail-label">Return %</div><div class="detail-value ${totalGainLoss >= 0 ? 'positive' : 'negative'}">${hasLivePrice ? formatPercentage(totalReturnPercentage) : '...'}</div></div>
                    <div class="detail-item"><div class="detail-label">Today's G/L $</div><div class="detail-value ${todayGLLabelClass}">${todayGLAmountDisplay}</div></div>
                    <div class="detail-item"><div class="detail-label">Today's G/L %</div><div class="detail-value ${todayGLLabelClass}">${todayGLPercentDisplay}</div></div>
                    <div class="detail-item"><div class="detail-label">Annual Income</div><div class="detail-value">${formatCurrency(annualIncome)}</div></div>
                    <div class="detail-item"><div class="detail-label">Yield on Cost</div><div class="detail-value">${formatPercentage(yieldOnCost)}</div></div>
                    <div class="detail-item"><div class="detail-label">Platform</div><div class="detail-value">${h.platform}</div></div>
                `;
            }
            // --- END MODIFIED G/L LOGIC ---
            
            const uniqueKey = `${h.symbol}|||${h.accountType}|||${h.platform}`;
            const isHistoryExpanded = !!uiState.expandedTransactions[uniqueKey];
            const transactionsHtml = `
                <div class="transaction-history ${isHistoryExpanded ? 'expanded' : ''}">
                    <div class="transaction-history-header" onclick="toggleTransactionHistory('${uniqueKey}')">
                        <h4>Transaction History</h4>
                        <span class="toggle-icon">${isHistoryExpanded ? '&#9660;' : '&#9658;'}</span>
                    </div>
                    <div class="transaction-table-container">
                        <table class="transaction-table">
                            <thead>
                                <tr><th>Date</th><th>Type</th><th>Shares</th><th>Price</th><th>Total</th><th>Actions</th></tr>
                            </thead>
                            <tbody>
                                ${(h.transactions || []).sort((a,b) => new Date(b.date) - new Date(a.date)).map(t => `
                                    <tr>
                                        <td>${t.date}</td>
                                        <td>${t.transactionType}</td>
                                        <td>${t.shares ? t.shares.toLocaleString(undefined, {maximumFractionDigits: 4}) : 'N/A'}</td>
                                        <td>${t.price ? formatCurrency(t.price) : 'N/A'}</td>
                                        <td>${t.shares && t.price ? formatCurrency(t.shares * t.price) : (t.amount ? formatCurrency(t.amount) : 'N/A')}</td>
                                        <td class="transaction-actions">
                                            <button class="btn btn-edit" onclick="openEditModal(${t.id})">Edit</button>
                                            <button class="btn btn-danger" onclick="removeTransaction(${t.id})">Del</button>
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
            return `<div class="investment-item">
                <div class="investment-header">
                    ${headerHtml}
                </div>
                <div class="investment-details">
                   ${detailsHtml}
                </div>
                ${isWatchlist ? '' : transactionsHtml}
            </div>`;
        }

        function renderConsolidatedHolding(symbol, accountType, holdings) {
            const totalShares = holdings.reduce((sum, h) => sum + (Number(h.totalShares) || 0), 0);
            const totalCost = holdings.reduce((sum, h) => sum + (Number(h.totalCost) || 0), 0);
            const hasLivePrice = holdings[0]?.currentPrice !== null && holdings[0]?.currentPrice > 0;
            const currentPrice = holdings[0]?.currentPrice || 0;
            const previousClosePrice = holdings[0]?.previousClosePrice || 0;
            const totalValue = hasLivePrice ? totalShares * currentPrice : 0; 
            const avgCostBasis = totalShares > 0 ? totalCost / totalShares : 0;
            const overallPL = hasLivePrice ? totalValue - totalCost : 0;
            const overallPLPercent = hasLivePrice && totalCost > 0 ? overallPL / totalCost : 0;

            let todayPL = 0;
            let todayPLPercent = 0;
            
            // --- MODIFIED G/L LOGIC (for display) ---
            const isRetirementOr529 = accountType === '401(k)' || accountType === '529 College Saving';
            const cachedInfo = priceCache[symbol] || {};
            let canIncludeDailyGL = true;
            if (isRetirementOr529) {
                const manualTimestamp = cachedInfo.manualPriceEntryTimestamp || 0;
                const twentyFourHoursAgo = Date.now() - (24 * 60 * 60 * 1000);
                if (manualTimestamp < twentyFourHoursAgo) {
                    canIncludeDailyGL = false;
                }
            }

            if (canIncludeDailyGL && hasLivePrice && previousClosePrice > 0) {
                todayPL = (currentPrice - previousClosePrice) * totalShares;
                const previousTotalValue = previousClosePrice * totalShares;
                if (previousTotalValue > 0) {
                   todayPLPercent = todayPL / previousTotalValue;
                }
            }
            
            let todayPLLabelClass = todayPL >= 0 ? 'positive' : 'negative';
            let todayPLAmountDisplay = hasLivePrice && canIncludeDailyGL ? formatCurrency(todayPL) : (isRetirementOr529 ? '(Stale)' : '...');
            let todayPLPercentDisplay = hasLivePrice && canIncludeDailyGL ? formatPercentage(todayPLPercent) : '...';
            // --- END MODIFIED G/L LOGIC ---

            const allTransactions = holdings.flatMap(h => h.transactions);

            const purchasesHtml = holdings.map(h => `
                <div class="purchase-item">
                    <span>Shares: ${h.totalShares.toLocaleString(undefined, {maximumFractionDigits: 4})} @ ${formatCurrency(h.averagePurchasePrice)} on: <strong>${h.platform}</strong></span>
                    <div class="purchase-item-actions">
                        <button class="btn btn-edit" onclick="event.stopPropagation(); openHoldingEditModal('${h.symbol}', '${h.accountType}', '${h.platform}')">Edit</button>
                        <button class="btn btn-danger" onclick="event.stopPropagation(); removeHolding('${h.symbol}', '${h.accountType}', '${h.platform}')">Delete</button>
                    </div>
                </div>
            `).join('');

            const uniqueKey = `${symbol}|||${accountType}`;
            const isHistoryExpanded = !!uiState.expandedTransactions[uniqueKey];
            const transactionsHtml = `
                <div class="transaction-history ${isHistoryExpanded ? 'expanded' : ''}">
                   <div class="transaction-history-header" onclick="toggleTransactionHistory('${uniqueKey}')">
                        <h4>Transaction History</h4>
                        <span class="toggle-icon">${isHistoryExpanded ? '&#9660;' : '&#9658;'}</span>
                    </div>
                    <div class="transaction-table-container">
                        <table class="transaction-table">
                            <thead>
                               <tr><th>Date</th><th>Type</th><th>Platform</th><th>Shares</th><th>Price</th><th>Total</th><th>Actions</th></tr>
                            </thead>
                            <tbody>
                                ${allTransactions.sort((a,b) => new Date(b.date) - new Date(a.date)).map(t => `
                                    <tr>
                                        <td>${t.date}</td>
                                        <td>${t.transactionType}</td>
                                        <td>${t.platform}</td>
                                        <td>${t.shares ? t.shares.toLocaleString(undefined, {maximumFractionDigits: 4}) : 'N/A'}</td>
                                        <td>${t.price ? formatCurrency(t.price) : 'N/A'}</td>
                                        <td>${t.shares && t.price ? formatCurrency(t.shares * t.price) : (t.amount ? formatCurrency(t.amount) : 'N/A')}</td>
                                        <td class="transaction-actions">
                                            <button class="btn btn-edit" onclick="openEditModal(${t.id})">Edit</button>
                                            <button class="btn btn-danger" onclick="removeTransaction(${t.id})">Del</button>
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;

            return `
            <div class="investment-item consolidated">
                <div class="investment-header">
                   <div class="investment-header-info">
                        <div class="investment-symbol">${symbol}</div>
                        <div style="color: var(--text-color-secondary); font-size: 0.9em;">${holdings[0].name} â€¢ Multiple Platforms</div>
                    </div>
                    <div class="investment-header-summary">
                       <div class="detail-value" style="font-size: 1.4em;">${hasLivePrice ? formatCurrency(currentPrice) : '...'}</div>
                       <div class="detail-value ${todayPLLabelClass}">${hasLivePrice ? `${formatCurrency(currentPrice - previousClosePrice)} (${formatPercentage(todayPLPercent)})` : '...'}</div>
                    </div>
                </div>
                <div class="investment-details">
                    <div class="consolidated-summary">
                        <div class="summary-item"><span>Total Shares:</span> <span>${totalShares.toLocaleString(undefined, { maximumFractionDigits: 4 })}</span></div>
                        <div class="summary-item"><span>Total Value:</span> <span>${hasLivePrice ? formatCurrency(totalValue) : '...'}</span></div>
                        <div class="summary-item"><span>Avg. Cost Basis:</span> <span>${formatCurrency(avgCostBasis)}</span></div>
                    </div>
                    <div class="purchase-breakdown">
                        <h4>Purchases in ${accountType}:</h4>
                        ${purchasesHtml}
                    </div>
                    <div class="consolidated-footer">
                        <div class="summary-item"><span>Overall P/L:</span> <span class="detail-value ${overallPL >= 0 ? 'positive' : 'negative'}">${hasLivePrice ? `${formatCurrency(overallPL)} (${formatPercentage(overallPLPercent)})` : '...'}</span></div>
                        <div class="summary-item"><span>P/L Today:</span> <span class="detail-value ${todayPLLabelClass}">${todayPLAmountDisplay}</span></div>
                    </div>
                           ${transactionsHtml}
                </div>
            </div>
            `;
        }
        // --- End Calculation/Rendering ---

        // --- Main Update Function (Unchanged) ---
        async function updateDisplay(fetchHistorical = true) {
            if (isUpdatingDisplay) return; 
            isUpdatingDisplay = true;

            try {
                if (!isInitialDataLoaded) return;
                const currentHoldings = calculateHoldingsAndCash();
                const stats = calculateOverallStats(currentHoldings);
                updateUserNameDisplay();
                updateStats(stats);
                if (fetchHistorical) {
                    await filterChart(activeChartFilter);
                }
                populatePlatformFilter();
                renderInvestments(currentHoldings);
                renderAllTransactions();
            } finally {
                isUpdatingDisplay = false;
            }
        }
        // --- End Main Update ---

        // --- MODAL Functions for Editing Data (Unchanged) ---
        function openEditModal(transactionId) {
            const transaction = portfolioData.transactions.find(t => t.id == transactionId);
            if (!transaction) return;
            const modal = document.getElementById('editTransactionModal');
            document.getElementById('editTransactionId').value = transactionId;
            document.getElementById('editTransactionDate').value = transaction.date;

            const fieldsContainer = document.getElementById('editTransactionFields');
            fieldsContainer.innerHTML = ''; 
            const type = transaction.transactionType.toUpperCase();

            if (type === 'DEPOSIT' || type === 'WITHDRAWAL' || type === 'DIVIDEND') {
                const amount = transaction.shares; 
                fieldsContainer.innerHTML = `
                    <div class="form-group">
                        <label>Amount</label>
                        <input type="number" id="editAmount" step="any" value="${amount || ''}">
                    </div>
                `;
            } else {
               fieldsContainer.innerHTML = `
                    <div class="form-group">
                        <label>Shares</label>
                        <input type="number" id="editShares" step="any" value="${transaction.shares || ''}">
                    </div>
                   <div class="form-group">
                        <label>Price</label>
                        <input type="number" id="editPrice" step="any" value="${transaction.price || ''}">
                    </div>
                `;
            }
            modal.style.display = 'flex';
        }

        function closeEditModal() {
            document.getElementById('editTransactionModal').style.display = 'none';
        }

        async function saveTransactionEdit() {
            const transactionId = document.getElementById('editTransactionId').value;
            const transactionIndex = portfolioData.transactions.findIndex(t => t.id == transactionId);
            if (transactionIndex === -1) return;
            const transaction = portfolioData.transactions[transactionIndex];
            transaction.date = document.getElementById('editTransactionDate').value;
            const type = transaction.transactionType.toUpperCase();

            if (type === 'DEPOSIT' || type === 'WITHDRAWAL' || type === 'DIVIDEND') {
                const amount = parseFloat(document.getElementById('editAmount').value);
                transaction.shares = amount;
                transaction.price = 1;
            } else {
                transaction.shares = parseFloat(document.getElementById('editShares').value);
                transaction.price = parseFloat(document.getElementById('editPrice').value);
            }

            logActivity(`Edited transaction for ${transaction.symbol}.`);
            await saveDataToFirestore();
            closeEditModal();
        }

        function openHoldingEditModal(symbol, accountType, platform) {
            const currentHoldings = calculateHoldingsAndCash();
            const positionKey = `${symbol}|||${accountType}|||${platform}`;
            const holding = currentHoldings.find(h => `${h.symbol}|||${h.accountType}|||${h.platform}` === positionKey);
            if (!holding) return;

            const modal = document.getElementById('editHoldingModal');
            document.getElementById('editHoldingSymbol').value = symbol;
            document.getElementById('editHoldingAccountTypeKey').value = accountType;
            document.getElementById('editHoldingPlatformKey').value = platform;
            document.getElementById('editHoldingSymbolDisplay').value = `${symbol} (${accountType} - ${platform})`;
            
            document.getElementById('editHoldingType').value = holding.type || '';
            document.getElementById('editHoldingTotalShares').value = holding.totalShares;
            document.getElementById('editHoldingAvgPrice').value = holding.averagePurchasePrice;
            
            const cachedInfo = priceCache[symbol] || {};
            
            const manualPriceInput = document.getElementById('editHoldingManualPrice');
            manualPriceInput.value = cachedInfo.manualPrice || '';
            
            const manualPCInput = document.getElementById('editHoldingManualPC');
            manualPCInput.value = cachedInfo.manualPreviousClosePrice || '';

            // --- MODIFIED: Show timestamp ---
            const manualTimestamp = cachedInfo.manualPriceEntryTimestamp;
            const timestampDisplay = document.getElementById('manualPriceTimestampDisplay');
            if (manualTimestamp) {
                const ageInHours = (Date.now() - manualTimestamp) / (1000 * 60 * 60);
                let status = ageInHours <= 24 ? ' (Fresh)' : ' (Stale)';
                timestampDisplay.textContent = `Manual prices last set: ${new Date(manualTimestamp).toLocaleString()}${status}`;
            } else {
                timestampDisplay.textContent = 'Manual prices not set.';
            }
            // --- END MODIFICATION ---

            modal.style.display = 'flex';
        }

        function closeHoldingEditModal() {
            document.getElementById('editHoldingModal').style.display = 'none';
        }

        async function saveHoldingEdit() {
            const symbol = document.getElementById('editHoldingSymbol').value;
            const accountType = document.getElementById('editHoldingAccountTypeKey').value;
            const platform = document.getElementById('editHoldingPlatformKey').value;
            const newType = document.getElementById('editHoldingType').value;

            const currentHoldings = calculateHoldingsAndCash();
            const holding = currentHoldings.find(h => h.symbol === symbol && h.accountType === accountType && h.platform === platform);
            
            const newTotalShares = parseFloat(document.getElementById('editHoldingTotalShares').value);
            const newAvgPrice = parseFloat(document.getElementById('editHoldingAvgPrice').value);
            
            const newManualPrice = parseFloat(document.getElementById('editHoldingManualPrice').value);
            const newManualPC = parseFloat(document.getElementById('editHoldingManualPC').value);

            if (!priceCache[symbol]) priceCache[symbol] = {};

            // --- MODIFIED: Set timestamp ---
            const manualPriceSet = !isNaN(newManualPrice) && newManualPrice >= 0;
            const manualPCSet = !isNaN(newManualPC) && newManualPC >= 0;

            if (manualPriceSet || manualPCSet) {
                priceCache[symbol].manualPriceEntryTimestamp = Date.now();
            }

            // --- Update Manual Current Price ---
            if (manualPriceSet) {
                priceCache[symbol].manualPrice = newManualPrice;
                priceCache[symbol].currentPrice = newManualPrice;
            } else {
                delete priceCache[symbol].manualPrice;
            }
            
            // --- Update Manual Previous Close Price ---
            if (manualPCSet) {
                priceCache[symbol].manualPreviousClosePrice = newManualPC;
                priceCache[symbol].previousClosePrice = newManualPC;
            } else {
                delete priceCache[symbol].manualPreviousClosePrice;
            }

            // If both are cleared, remove the timestamp
            if (!manualPriceSet && !manualPCSet) {
                 delete priceCache[symbol].manualPriceEntryTimestamp;
            }
            // --- END MODIFICATION ---


            if (holding) {
                const sharesChanged = Math.abs(newTotalShares - holding.totalShares) > 0.00001;
                const priceChanged = Math.abs(newAvgPrice - holding.averagePurchasePrice) > 0.00001;
                const typeChanged = newType !== holding.type;
                
                 let needsDataSave = false; 

                if (sharesChanged || priceChanged) {
                    showConfirmationModal(
                        `This will replace all existing transactions for ${symbol} in this position with a single summary transaction. Are you sure?`,
                        async () => { // onConfirm
                            const otherTransactions = portfolioData.transactions.filter(t => !(t.symbol === symbol && t.accountType === accountType && t.platform === platform));
                            const summaryTransaction = {
                                id: Date.now(),
                                transactionType: 'BUY',
                                date: new Date().toISOString().split('T')[0], 
                                symbol: symbol,
                                name: holding.name, 
                                shares: newTotalShares,
                                price: newAvgPrice,
                                dividend: holding.dividend, 
                                type: newType, 
                                accountType: accountType,
                                platform: platform,
                            };
                            portfolioData.transactions = [...otherTransactions, summaryTransaction];
                            logActivity(`Edited holding (summary override) for ${symbol} in ${accountType} - ${platform}.`);
                            
                            await saveDataToFirestore(); 
                            closeHoldingEditModal();
                        },
                        () => { // onCancel 
                             logActivity(`Updated manual prices for ${symbol} in ${accountType} - ${platform}.`);
                             saveDataToFirestore(); 
                             closeHoldingEditModal();
                        }
                    );
                     return; 
                } else if (typeChanged) {
                    portfolioData.transactions.forEach(t => {
                        if (t.symbol === symbol && t.accountType === accountType && t.platform === platform) {
                            t.type = newType;
                        }
                    });
                     logActivity(`Changed holding type for ${symbol} in ${accountType} - ${platform} to ${newType}.`);
                     needsDataSave = true; 
                } else {
                     logActivity(`Updated manual prices for ${symbol} in ${accountType} - ${platform}.`);
                }

                if (needsDataSave || !(sharesChanged || priceChanged || typeChanged)) {
                    await saveDataToFirestore(); 
                }
            }
            closeHoldingEditModal();
        }

        async function toggleTransactionHistory(key) {
            uiState.expandedTransactions[key] = !uiState.expandedTransactions[key];
            await saveDataToFirestore();
            updateDisplay(false);
        }
        // --- End Modal Edit Functions ---

        // --- Utility and Charting Functions (Unchanged) ---
        function formatCurrency(amount) {
            if (typeof amount !== 'number') { return '$0.00'; }
            return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(amount);
        }
        function formatPercentage(value) {
            if (typeof value !== 'number') { return '0.00%'; }
            return (value * 100).toFixed(2) + '%';
        }
        function applyTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            document.querySelector('.theme-toggle').textContent = theme === 'dark' ? 'â˜€ï¸' : 'ðŸŒ™';
        }
        async function toggleTheme() {
            const newTheme = (document.documentElement.getAttribute('data-theme') || 'light') === 'dark' ? 'light' : 'dark';
            localStorage.setItem(THEME_KEY, newTheme);
            applyTheme(newTheme);
            await filterChart(activeChartFilter);
        }
        function loadTheme() {
            applyTheme(localStorage.getItem(THEME_KEY) || 'light');
        }

        function debouncedUpdateUserName() {
            clearTimeout(userNameUpdateTimeout);
            userNameUpdateTimeout = setTimeout(() => {
                updateUserName();
            }, 800);
        }

        async function updateUserName() {
            portfolioData.username = document.getElementById('userNameInput').value.trim();
            await saveDataToFirestore();
        }

        function updateUserNameDisplay() {
            const el = document.getElementById('userNameDisplay');
            const name = portfolioData.username;
            el.textContent = name ? `for ${name}` : '';
            document.getElementById('userNameInput').value = name;
            document.title = name ? `${name}'s Portfolio` : 'Investment App';
        }

        function getAccountBadgeClass(accountType) { const map = { 'Regular Brokerage': 'account-regular', 'Roth IRA': 'account-roth', '401(k)': 'account-401k', '529 College Saving': 'account-529', 'Yahoo Finance': 'account-yahoo' }; return map[accountType] || 'account-regular'; }
        function populatePlatformFilter() {
            const select = document.getElementById('filterPlatform');
            if(!portfolioData.transactions) return;
            const platforms = new Set(portfolioData.transactions.map(t => t.platform).filter(Boolean));
            while (select.options.length > 1) select.remove(1);
            platforms.forEach(p => { const o = document.createElement('option'); o.value = p; o.textContent = p; select.appendChild(o); });
            select.value = currentFilter;
        }

        function updateCharts(dataPoints, holdings) {
            const chartData = dataPoints || [];
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
            const gridColor = currentTheme === 'dark' ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
            const labelColor = currentTheme === 'dark' ? '#f5f5f5' : '#333';
            if(accountChart) accountChart.destroy(); if(investmentChart) investmentChart.destroy(); if(historicalChart) historicalChart.destroy(); if(dividendChart) dividendChart.destroy();

            const portfolioHoldings = holdings.filter(h => h.accountType !== WATCHLIST_ACCOUNT_TYPE);
            const accountData = portfolioHoldings.reduce((acc, h) => {
                const val = (Number(h.totalShares) || 0) * (h.currentPrice || 0); 
                if(h.currentPrice !== null && h.currentPrice > 0 && h.accountType) acc[h.accountType] = (acc[h.accountType] || 0) + val;
                return acc;
            }, {});
            const investmentData = portfolioHoldings.reduce((acc, h) => {
                 const val = (Number(h.totalShares) || 0) * (h.currentPrice || 0); 
                if(h.currentPrice !== null && h.currentPrice > 0 && h.type) acc[h.type] = (acc[h.type] || 0) + val; return acc;
             }, {});
            
            const chartTooltipCallback = function(context) {
                const label = context.label || '';
                const value = context.raw;
                const total = context.chart.getDatasetMeta(0).total;
                const percentage = ((value / total) * 100).toFixed(2) + '%';
                return `${label}: ${formatCurrency(value)} (${percentage})`;
            };

            const chartLegendLabelGenerator = function(chart) {
                const data = chart.data;
                if (data.labels.length && data.datasets.length) {
                    const total = data.datasets[0].data.reduce((sum, item) => sum + item, 0);
                    if (total === 0) {
                        return data.labels.map((label, i) => {
                            const meta = chart.getDatasetMeta(0);
                            const style = meta.controller.getStyle(i);
                             return { text: `${label}: 0.00%`, fillStyle: style.backgroundColor, strokeStyle: style.borderColor, lineWidth: style.borderWidth, hidden: !chart.getDataVisibility(i), index: i };
                        });
                    }
                    return data.labels.map((label, i) => {
                        const meta = chart.getDatasetMeta(0);
                        const style = meta.controller.getStyle(i);
                        const value = data.datasets[0].data[i];
                        const percentage = ((value / total) * 100).toFixed(2) + '%';
                        return { text: `${label}: ${percentage}`, fillStyle: style.backgroundColor, strokeStyle: style.borderColor, lineWidth: style.borderWidth, hidden: !chart.getDataVisibility(i), index: i };
                    });
                }
                return [];
            };

            if(Object.keys(accountData).length > 0) {
                 const accountColors = {'Regular Brokerage': '#3498db', 'Roth IRA': '#e74c3c', '401(k)': '#f39c12', '529 College Saving': '#9b59b6', 'Yahoo Finance': '#20c997'};
                 accountChart = new Chart(document.getElementById('accountChart').getContext('2d'), { type: 'doughnut', data: { labels: Object.keys(accountData), datasets: [{ data: Object.values(accountData), backgroundColor: Object.keys(accountData).map(l => accountColors[l] || '#95a5a6'), borderWidth: 3, borderColor: currentTheme === 'dark' ? '#121212' : '#f0f2f5' }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'bottom', labels: { color: labelColor, generateLabels: chartLegendLabelGenerator } }, tooltip: { callbacks: { label: chartTooltipCallback } } } } });
            }
           if(Object.keys(investmentData).length > 0) {
                 const investmentColors = {'Stock': '#2ecc71', 'ETF': '#3498db', 'Market Index': '#1abc9c', 'Bond': '#f39c12', 'Mutual Fund': '#9b59b6', 'Cryptocurrency': '#e67e22', 'Other': '#95a5a6', 'CASH': '#4CAF50', 'Money Market': '#4CAF50', '401k': '#f39c12'};
                 investmentChart = new Chart(document.getElementById('investmentChart').getContext('2d'), { type: 'pie', data: { labels: Object.keys(investmentData), datasets: [{ data: Object.values(investmentData), backgroundColor: Object.keys(investmentData).map(l => investmentColors[l] || '#95a5a6'), borderWidth: 3, borderColor: currentTheme === 'dark' ? '#121212' : '#f0f2f5' }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'bottom', labels: { color: labelColor, generateLabels: chartLegendLabelGenerator } }, tooltip: { callbacks: { label: chartTooltipCallback } } } } });
            }
            if (chartData && chartData.length > 0) {
                historicalChart = new Chart(document.getElementById('historicalChart').getContext('2d'), { type: 'line', data: { labels: chartData.map(dp => new Date(dp.date).toLocaleDateString()), datasets: [{ label: 'Portfolio Value', data: chartData.map(dp => dp.value), borderColor: 'var(--accent-color-1)', backgroundColor: 'rgba(109, 40, 217, 0.1)', fill: true, tension: 0.3 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { ticks: { color: labelColor, callback: v => formatCurrency(v) }, grid: { color: gridColor } }, x: { ticks: { color: labelColor }, grid: { color: gridColor } } }, plugins: { legend: { display: false } } } });
            }
            const dividendData = portfolioHoldings.map(h => {
                const totalShares = h.totalShares;
                return { symbol: h.symbol, income: (Number(totalShares) || 0) * (Number(h.dividend) || 0) };
            }).filter(d => d.income > 0).sort((a,b) => b.income - a.income);
            if (dividendData.length > 0) {
                 dividendChart = new Chart(document.getElementById('dividendChart').getContext('2d'), {
                     type: 'bar',
                     data: {
                         labels: dividendData.map(d => d.symbol),
                         datasets: [{ label: 'Annual Income', data: dividendData.map(d => d.income), backgroundColor: 'rgba(39, 174, 96, 0.6)', borderColor: 'rgba(39, 174, 96, 1)', borderWidth: 1 }]
                     },
                     options: {
                         indexAxis: 'y',
                         responsive: true, maintainAspectRatio: false,
                         scales: { x: { ticks: { color: labelColor, callback: v => formatCurrency(v) }, grid: { color: gridColor } }, y: { ticks: { color: labelColor }, grid: { color: gridColor } } },
                         plugins: { legend: { display: false } }
                     }
                  });
            }
        }

        function saveAutoRefreshState() { localStorage.setItem(AUTO_REFRESH_STATE_KEY, JSON.stringify(isAutoRefreshEnabled)); }
        function loadAutoRefreshState() { const s = localStorage.getItem(AUTO_REFRESH_STATE_KEY); isAutoRefreshEnabled = s !== null ? JSON.parse(s) : true; }
        function updateAutoRefreshButton() { const btn = document.getElementById('toggleAutoRefreshBtn'); if (isAutoRefreshEnabled) { btn.textContent = 'Pause Auto-Refresh'; btn.style.background = 'linear-gradient(45deg, #f39c12, #e67e22)'; } else { btn.textContent = 'Resume Auto-Refresh'; btn.style.background = 'linear-gradient(45deg, #27ae60, #2ecc71)'; } }
        
        function startAutoRefresh() {
            if (countdownIntervalId !== null) clearInterval(countdownIntervalId); 
            isAutoRefreshEnabled = true;

            const countdownEl = document.getElementById('countdown-timer');
            let timeLeft = autoRefreshIntervalSeconds;

            countdownEl.style.display = 'block';
            countdownEl.textContent = `Next update in: ${timeLeft}s`;

            countdownIntervalId = setInterval(() => {
                timeLeft--;
                if (timeLeft <= 0) {
                    refreshAllPrices(false);
                    timeLeft = autoRefreshIntervalSeconds;
                }
                countdownEl.textContent = `Next update in: ${timeLeft}s`;
            }, 1000);

            updateAutoRefreshButton();
            saveAutoRefreshState();
        }

        function stopAutoRefresh() { 
            if (countdownIntervalId !== null) { 
                clearInterval(countdownIntervalId); 
                countdownIntervalId = null; 
            } 
            document.getElementById('countdown-timer').style.display = 'none';
            isAutoRefreshEnabled = false; 
            updateAutoRefreshButton(); 
            saveAutoRefreshState(); 
        }

        function toggleAutoRefresh() { if (isAutoRefreshEnabled) stopAutoRefresh(); else { startAutoRefresh(); refreshAllPrices(true); } }
        
        async function filterChart(period) {
            const holdings = calculateHoldingsAndCash();
            const history = await buildPortfolioHistoryFromTransactions();
            
            activeChartFilter = period;
            document.querySelectorAll('.chart-filter-btn').forEach(btn => btn.classList.remove('active'));
            const activeBtn = Array.from(document.querySelectorAll('.chart-filter-btn')).find(b => b.textContent === period);
            if(activeBtn) activeBtn.classList.add('active');

            const now = new Date();
            let startDate;
            switch (period) {
                case '1W': startDate = new Date(new Date().setDate(now.getDate() - 7)); break;
                case '1M': startDate = new Date(new Date().setMonth(now.getMonth() - 1)); break;
                case '6M': startDate = new Date(new Date().setMonth(now.getMonth() - 6)); break;
                case 'YTD': startDate = new Date(now.getFullYear(), 0, 1); break;
                case '1Y': startDate = new Date(new Date().setFullYear(now.getFullYear() - 1)); break;
                case '3Y': startDate = new Date(new Date().setFullYear(now.getFullYear() - 3)); break;
                case '5Y': startDate = new Date(new Date().setFullYear(now.getFullYear() - 5)); break;
                default: updateCharts(history, holdings); return;
            }
            const filteredData = history.filter(dp => new Date(dp.date) >= startDate);
            updateCharts(filteredData, holdings);
        }

        function showTab(tabName) {
            activeTab = tabName;
            
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            document.getElementById(`${tabName}Tab`).classList.add('active');
            
            document.querySelectorAll('.tab-link').forEach(el => el.classList.remove('active'));
            event.target.classList.add('active');
        }

        function renderAllTransactions() {
            const container = document.getElementById('allTransactionsList');
            const transactions = portfolioData.transactions || [];
            
            if (transactions.length === 0) {
                container.innerHTML = `<div class="empty-state">ðŸ“Š<p>No transactions found.</p></div>`;
                return;
            }

            const sorted = [...transactions].sort((a,b) => new Date(b.date) - new Date(a.date));

            const tableHtml = `
                <table class="transaction-table">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Account</th>
                            <th>Symbol</th>
                            <th>Type</th>
                            <th>Shares</th>
                            <th>Price</th>
                            <th>Total</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${sorted.map(t => `
                            <tr>
                                <td>${t.date}</td>
                                <td>${t.accountType} (${t.platform})</td>
                                <td>${t.symbol}</td>
                                <td>${t.transactionType}</td>
                                <td>${t.shares ? t.shares.toLocaleString(undefined, {maximumFractionDigits: 4}) : 'N/A'}</td>
                                <td>${t.price ? formatCurrency(t.price) : 'N/A'}</td>
                                <td>${t.shares && t.price ? formatCurrency(t.shares * t.price) : (t.amount ? formatCurrency(t.amount) : 'N/A')}</td>
                                <td class="transaction-actions">
                                    <button class="btn btn-edit" onclick="openEditModal(${t.id})">Edit</button>
                                    <button class="btn btn-danger" onclick="removeTransaction(${t.id})">Del</button>
                                </td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;

            container.innerHTML = tableHtml;
        }

        // --- MODIFIED: updateDataStatus to integrate with the new modal experience ---
        function updateDataStatus(isSaved, msg = "") {
             const el = document.getElementById('dataStatus');
             el.classList.remove('saved', 'loading', 'error');
             if (isSaved === true) {
                 el.textContent = 'â˜ï¸ Synced'; el.classList.add('saved');
             } else if (isSaved === 'loading') {
                 // The detailed scanning modal handles the "loading" state now
                 el.textContent = 'ðŸ”„ Scanning...'; el.classList.add('loading');
             } else if (isSaved === 'error') {
                el.textContent = `âš ï¸ Error: ${msg}`; el.classList.add('error');
             } else {
                 el.textContent = '...';
            }
        }
        // --- END MODIFIED DEFINITION ---

        // --- Import/Export Functions (Unchanged) ---
        function exportCSV() {
            if (!portfolioData.transactions || portfolioData.transactions.length === 0) {
                showConfirmationModal("No transactions to export.", null);
                return;
            }
            const csv = Papa.unparse(portfolioData.transactions);
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = `transactions_${new Date().toISOString().split('T')[0]}.csv`;
            link.click();
            logActivity('Exported transactions to CSV.');
            saveDataToFirestore();
        }

        function triggerCsvImport() {
             document.getElementById('csvFileInput').click();
        }

        function handleCsvImport(e) {
            const file = e.target.files[0];
            if (!file) return;

            Papa.parse(file, {
                header: true,
                dynamicTyping: false,
                skipEmptyLines: true,
                complete: function(results) {
                    if (results.errors.length > 0) {
                        console.error("CSV Parsing Errors:", results.errors);
                        showConfirmationModal("Error parsing CSV file. Some rows may be malformed. Check console for details.", null);
                    }
                    if (results.data.length === 0) {
                        showConfirmationModal("Import failed: CSV file is empty or contains no valid data rows.", null);
                        return;
                    }
                    let transactionsToImport = results.data.map((row, index) => {
                        const cleanedRow = {};
                        for (const key in row) {
                            cleanedRow[key] = typeof row[key] === 'string' ? row[key].trim() : row[key];
                        }
                        cleanedRow.id = parseFloat(cleanedRow.id) || Date.now() + index;
                        cleanedRow.shares = parseFloat(cleanedRow.shares) || 0;
                        cleanedRow.price = parseFloat(cleanedRow.price) || 0;
                        cleanedRow.dividend = parseFloat(cleanedRow.dividend) || 0;
                        cleanedRow.amount = parseFloat(cleanedRow.amount) || null;
                        return cleanedRow;
                    });
                    showConfirmationModal(`You are about to import ${transactionsToImport.length} transactions. This will overwrite ALL current data in the cloud. Continue?`, async () => {
                        portfolioData.transactions = transactionsToImport;
                        logActivity(`Imported ${transactionsToImport.length} transactions from CSV.`);
                        await saveDataToFirestore();
                        updateDisplay();
                       showConfirmationModal(`Successfully imported ${transactionsToImport.length} transactions.`, null);
                    });
                    e.target.value = null;
                },
                error: (err) => {
                    showConfirmationModal(`A critical error occurred during import: ${err.message}`, null)
                    e.target.value = null;
                },
            });
        }
        
        async function refreshMutualFunds() {
            // Note: Mutual fund refresh will now use the new progress modal as well.
            await refreshAllPrices(true, true); // The second 'true' flag can be used internally to distinguish MF only logic if needed, but for now, it's covered by forceRefresh=true and logic within fetchPrice.
            showConfirmationModal("Mutual fund price refresh complete.", null);
        }
        // --- End Import/Export ---

        // --- Visibility Toggle (Unchanged) ---
        function toggleStatsVisibility() {
            isStatsVisible = !isStatsVisible;
            localStorage.setItem(STATS_VISIBILITY_KEY, isStatsVisible);
            applyStatsVisibility();
        }

        function applyStatsVisibility() {
            const body = document.body;
            const icon = document.querySelector('.visibility-toggle');
            if (isStatsVisible) {
                body.classList.remove('stats-hidden');
                icon.textContent = 'ðŸ‘ï¸';
            } else {
                body.classList.add('stats-hidden');
                icon.textContent = 'ðŸ™ˆ';
            }
        }

        function loadStatsVisibility() {
            const savedState = localStorage.getItem(STATS_VISIBILITY_KEY);
            isStatsVisible = savedState !== null ? JSON.parse(savedState) : true;
            applyStatsVisibility();
        }
        // --- End Visibility ---


        // Make functions globally accessible for inline HTML onclick handlers
        window.toggleTheme = toggleTheme;
        window.openSettingsModal = openSettingsModal;
        window.closeSettingsModal = closeSettingsModal;
        window.saveSettings = saveSettings;
        window.toggleAutoRefresh = toggleAutoRefresh;
        window.refreshAllPrices = refreshAllPrices;
        window.filterChart = filterChart;
        window.toggleAddForm = toggleAddForm;
        window.toggleTransactionFields = toggleTransactionFields;
        window.validateSymbol = validateSymbol;
        window.handleAccountTypeChange = handleAccountTypeChange;
        window.updateTransactionFields = updateTransactionFields;
        window.logTransaction = logTransaction;
        window.exportCSV = exportCSV;
        window.triggerCsvImport = triggerCsvImport;
        window.clearAllData = clearAllData;
        window.updateUserName = updateUserName;
        window.debouncedUpdateUserName = debouncedUpdateUserName;
        window.toggleGroup = toggleGroup;
        window.removeHolding = removeHolding;
        window.openHoldingEditModal = openHoldingEditModal;
        window.closeHoldingEditModal = closeHoldingEditModal;
        window.saveHoldingEdit = saveHoldingEdit;
        window.toggleTransactionHistory = toggleTransactionHistory;
        window.openEditModal = openEditModal;
        window.closeEditModal = closeEditModal;
        window.saveTransactionEdit = saveTransactionEdit;
        window.removeTransaction = removeTransaction;
        window.refreshMutualFunds = refreshMutualFunds;
        window.openRecurringPurchaseModal = openRecurringPurchaseModal;
        window.closeRecurringPurchaseModal = closeRecurringPurchaseModal;
        window.saveRecurringPurchase = saveRecurringPurchase;
        window.deleteRecurringPurchase = deleteRecurringPurchase;
        window.openActivityLogModal = openActivityLogModal;
        window.closeActivityLogModal = closeActivityLogModal;
        window.showTab = showTab;
        window.toggleStatsVisibility = toggleStatsVisibility;
        window.signOutOtherDevices = signOutOtherDevices; 
        window.closeScanningModal = closeScanningModal; // Global access for new modal
    </script>

    <!-- MODALS -->
    <div id="confirmationModal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-btn" onclick="document.getElementById('confirmationModal').style.display='none'">Ã—</button>
            <p id="modalMessage" class="modal-message"></p>
            <div class="modal-buttons">
                <button id="modalConfirmBtn" class="btn btn-confirm">Confirm</button>
                <button id="modalCancelBtn" class="btn btn-cancel">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- NEW: Scanning Progress Modal -->
    <div id="syncingProgressModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div id="progressContainer">
                <p id="progressMessage">Starting scan...</p>
                <div id="progressBar">
                    <div id="progressBarFill"></div>
                </div>
                <div id="summaryBox">
                    Click "Refresh Now" to start scanning.
                </div>
            </div>
             <div class="modal-buttons">
                <button id="modalCloseBtn" class="btn btn-cancel" onclick="closeScanningModal()" style="display:none; width: auto;">Close</button>
            </div>
        </div>
    </div>
    <!-- END NEW MODAL -->

    <div id="editTransactionModal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-btn" onclick="closeEditModal()">Ã—</button>
            <h3>Edit Transaction</h3>
            <input type="hidden" id="editTransactionId">
            <div class="form-group">
                <label for="editTransactionDate">Date</label>
                <input type="date" id="editTransactionDate">
            </div>
            <div id="editTransactionFields"></div>
            <div class="modal-buttons">
                <button class="btn btn-confirm" onclick="saveTransactionEdit()">Save</button>
                <button class="btn btn-cancel" onclick="closeEditModal()">Cancel</button>
            </div>
        </div>
    </div>
    <div id="editHoldingModal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-btn" onclick="closeHoldingEditModal()">Ã—</button>
            <h3>Edit Position Details</h3>
            <input type="hidden" id="editHoldingSymbol">
            <input type="hidden" id="editHoldingAccountTypeKey">
            <input type="hidden" id="editHoldingPlatformKey">
            <div class="form-group">
                <label>Symbol</label>
                <input type="text" id="editHoldingSymbolDisplay" disabled>
            </div>
            <div class="form-group">
                <label for="editHoldingType">Investment Type</label>
                <select id="editHoldingType">
                    <option value="Stock">Stock</option>
                    <option value="ETF">ETF</option>
                    <option value="Market Index">Market Index</option>
                    <option value="401k">401k</option>
                    <option value="Bond">Bond</option>
                    <option value="Mutual Fund">Mutual Fund</option>
                    <option value="Cryptocurrency">Cryptocurrency</option>
                    <option value="Money Market">Money Market</option>
                    <option value="Manual">Manual (No Price Fetch)</option>
                    <option value="Other">Other</option>
                    <option value="CASH">CASH</option>
                </select>
            </div>
            <div class="form-group">
                <label for="editHoldingTotalShares">Total Shares</label>
                <input type="number" id="editHoldingTotalShares" step="any" min="0">
                <small>Adjusting this will replace transactions for this specific position with a single summary record.</small>
            </div>
            <div class="form-group">
                <label for="editHoldingAvgPrice">Average Cost / Share</label>
                <input type="number" id="editHoldingAvgPrice" step="any" min="0">
                <small>Adjusting this will replace transactions for this specific position with a single summary record.</small>
            </div>
            <div class="form-group">
                <label for="editHoldingManualPrice">Manual Current Price / Share (Optional)</label>
                <input type="number" id="editHoldingManualPrice" step="any" min="0">
                <small>Use this to override the live price if fetching fails. Leave blank to use live data.</small>
            </div>
            <div class="form-group">
                <label for="editHoldingManualPC">Manual Previous Close Price / Share (Optional)</label>
                <input type="number" id="editHoldingManualPC" step="any" min="0">
                <small>Required to manually calculate **Today's G/L** when using a manual current price.</small>
                <!-- MODIFIED: Added timestamp display -->
                <small id="manualPriceTimestampDisplay" style="color: var(--accent-color-1); display: block; margin-top: 4px;"></small>
            </div>
            <div class="modal-buttons">
                <button class="btn btn-confirm" onclick="saveHoldingEdit()">Save</button>
                <button class="btn btn-cancel" onclick="closeHoldingEditModal()">Cancel</button>
            </div>
        </div>
    </div>
    <div id="settingsModal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-btn" onclick="closeSettingsModal()">Ã—</button>
            <h3>Settings</h3>
            <div class="form-group">
                <label for="finnhubApiKeyInput">Finnhub API Key</label>
                <input type="text" id="finnhubApiKeyInput" placeholder="Enter your Finnhub API Key">
            </div>
            <div class="form-group">
                <label for="fmpApiKeyInput">Financial Modeling Prep (FMP) API Key</label>
                <input type="text" id="fmpApiKeyInput" placeholder="Enter your FMP API Key">
                <small>Used for Mutual Fund lookups before falling back to Alpha Vantage.</small>
            </div>
            <div class="form-group">
                <label for="alphaVantageApiKeyInput">Alpha Vantage API Key</label>
                <input type="text" id="alphaVantageApiKeyInput" placeholder="Enter your Alpha Vantage API Key">
            </div>
            <div class="form-group">
                <label for="autoRefreshIntervalInput">Auto-Refresh Interval (seconds)</label>
                <input type="number" id="autoRefreshIntervalInput" step="1" min="30" placeholder="e.g., 75">
                <small>Minimum 30 seconds to respect API limits.</small>
            </div>
            
            <!-- INTEGRATED: Sign Out Other Devices Button -->
            <div class="form-group" style="border-top: 1px solid var(--border-color); padding-top: 15px; margin-top: 15px;">
                <label>Security</label>
                <button class="btn btn-danger" id="signOutOthersBtn" onclick="signOutOtherDevices()" style="width: 100%; background: #c0392b;">Sign Out All Other Devices</button>
                <small>This will sign out all other active sessions of this app.</small>
            </div>
            <!-- END INTEGRATED SECTION -->
            
            <div class="modal-buttons" style="margin-top: 20px;">
                <button class="btn btn-confirm" onclick="saveSettings()">Save Settings</button>
            </div>
        </div>
    </div>

    <div id="recurringPurchaseModal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-btn" onclick="closeRecurringPurchaseModal()">Ã—</button>
            <h3>Set Up Recurring Purchase</h3>
            <div class="form-group">
                <label for="recurringSymbol">Symbol</label>
                <input type="text" id="recurringSymbol" placeholder="e.g., VOO, VTI" required>
            </div>
            <div class="form-group">
                <label for="recurringAmount">Purchase Amount ($)</label>
                <input type="number" id="recurringAmount" step="any" min="0" placeholder="100.00" required>
            </div>
            <div class="form-group">
                <label for="recurringFrequency">Frequency</label>
                <select id="recurringFrequency" required>
                    <option value="weekly">Weekly</option>
                    <option value="bi-weekly">Every 2 Weeks</option>
                    <option value="monthly">Monthly</option>
                </select>
            </div>
            <div class="form-group">
                <label for="recurringStartDate">Start Date</label>
                <input type="date" id="recurringStartDate" required>
            </div>
            <div class="form-group">
                <label for="recurringAccountType">Account Type</label>
                <select id="recurringAccountType" required>
                    <option value="">Select Account</option>
                    <option value="Regular Brokerage">Regular Brokerage</option>
                    <option value="Roth IRA">Roth IRA</option>
                    <option value="401(k)">401(k)</option>
                    <option value="529 College Saving">529 College Saving</option>
                </select>
            </div>
            <div class="form-group">
                <label for="recurringPlatform">Platform</label>
                 <select id="recurringPlatform" required>
                    <option value="">Select Platform</option>
                    <option value="Fidelity">Fidelity</option>
                    <option value="Vanguard">Vanguard</option>
                    <option value="Charles Schwab">Charles Schwab</option>
                    <option value="Merrill Edge">Merrill Edge</option>
                    <option valuef="E*TRADE">E*TRADE</option>
                    <option value="Other">Other</option>
                </select>
            </div>
            <div class="modal-buttons" style="margin-top: 10px;">
                <button class="btn btn-confirm" onclick="saveRecurringPurchase()">Save Schedule</button>
            </div>
            <hr style="border: none; border-top: 1px solid var(--border-color); margin: 20px 0;">
            <h4>Active Schedules</h4>
            <div id="recurring-purchases-list"></div>
        </div>
    </div>
    
    <div id="activityLogModal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-btn" onclick="closeActivityLogModal()">Ã—</button>
            <h3>Activity Log (Last 15 Years)</h3>
            <div id="activity-log-list" style="max-height: 400px; overflow-y: auto;"></div>
        </div>
    </div>


    <div class="container">
        <div class="header">
            <div class="header-top-row">
                <div class="header-left">
                    <div class="theme-toggle header-icon" onclick="toggleTheme()">â˜€ï¸</div>
                    <div id="auth-container">
                        <button id="signInBtn" class="btn" style="width:auto; display:none;">Sign in with Google</button>
                        <div id="user-info" style="display:none;">
                            <img id="userPhoto" src="" alt="User photo">
                            <span id="userName"></span>
                            <button id="signOutBtn" class="btn btn-danger">Sign Out</button>
                        </div>
                    </div>
                </div>
                <div class="data-status" id="dataStatus">...</div>
                <div class="header-right">
                    <div class="visibility-toggle header-icon" onclick="toggleStatsVisibility()">ðŸ‘ï¸</div>
                    <div class="activity-log-toggle header-icon" onclick="openActivityLogModal()">ðŸ“œ</div>
                    <div class="settings-toggle header-icon" onclick="openSettingsModal()">âš™ï¸</div>
                </div>
            </div>
            <h1>ðŸ’° Investment App <span id="userNameDisplay"></span></h1>
            <p>Track your investments with a detailed transaction log</p>
            <div class="form-group" style="max-width: 300px; margin: 15px auto 0;">
                <label for="userNameInput" style="color: var(--text-color-primary); font-weight: normal; font-size: 0.9em;">Your Name:</label>
                <input type="text" id="userNameInput" placeholder="Enter your name" style="background: rgba(255, 255, 255, 0.9); border: none; color: #333;">
            </div>
        </div>
        <div class="stats-grid">
            <div class="stat-card"> <div class="stat-value" id="totalValue">$0.00</div> <div class="stat-label">Total Portfolio Value</div> </div> <div class="stat-card"> <div class="stat-value" id="totalInvested">$0.00</div> <div class="stat-label">Total Cost Basis</div> </div> <div class="stat-card"> <div class="stat-value" id="totalCashValue">$0.00</div> <div class="stat-label">Cash & Money Market</div> </div> <div class="stat-card"> <div class="stat-value" id="unrealizedGainLoss">$0.00</div> <div class="stat-label">Unrealized G/L</div> </div> <div class="stat-card"> <div class="stat-value" id="realizedGainLoss">$0.00</div> <div class="stat-label">Realized G/L</div> </div> <div class="stat-card"> <div class="stat-value" id="todayPortfolioGainLoss">$0.00</div> <div class="stat-label">Today's G/L</div> </div> <div class="stat-card"> <div class="stat-value" id="estimatedAnnualIncome">$0.00</div> <div class="stat-label">Est. Annual Income</div> </div> <div class="stat-card"> <div class="stat-value" id="portfolioYieldOnCost">0.00%</div> <div class="stat-label">Portfolio Yield on Cost</div> </div> <div class="stat-card"> <div class="stat-value" id="bestPerformerValue">$0.00</div> <div class="stat-label">Best Performer (<span id="bestPerformerSymbol">N/A</span>)</div> </div> <div class="stat-card"> <div class="stat-value" id="worstPerformerValue">$0.00</div> <div class="stat-label">Worst Performer (<span id="worstPerformerSymbol">N/A</span>)</div> </div>
        </div>
        <div class="refresh-button-container">
            <button type="button" class="btn" id="toggleAutoRefreshBtn" onclick="toggleAutoRefresh()">Pause Auto-Refresh</button>
            <button type="button" class="btn btn-secondary" id="refreshMFBtn" onclick="refreshMutualFunds()">Refresh Mutual Funds</button>
            <button type="button" class="btn" onclick="refreshAllPrices(true)">Refresh Now</button>
        </div>
        <div class="charts-section">
            <div class="chart-container">
                <h3>Portfolio Performance History</h3>
                <div class="chart-filters">
                    <button class="chart-filter-btn" onclick="filterChart('1W')">1W</button>
                    <button class="chart-filter-btn" onclick="filterChart('1M')">1M</button>
                    <button class="chart-filter-btn" onclick="filterChart('6M')">6M</button>
                    <button class="chart-filter-btn" onclick="filterChart('YTD')">YTD</button>
                    <button class="chart-filter-btn" onclick="filterChart('1Y')">1Y</button>
                    <button class="chart-filter-btn" onclick="filterChart('3Y')">3Y</button>
                    <button class="chart-filter-btn" onclick="filterChart('5Y')">5Y</button>
                    <button class="chart-filter-btn active" onclick="filterChart('All')">All</button>
                </div>
                <div class="chart-wrapper"> <canvas id="historicalChart"></canvas> </div>
            </div>
            <div class="pie-charts-container">
                <div class="chart-container"> <h3>Portfolio by Account Type</h3> <div class="chart-wrapper"> <canvas id="accountChart"></canvas> </div> </div>
                <div class="chart-container"> <h3>Portfolio by Investment Type</h3> <div class="chart-wrapper"> <canvas id="investmentChart"></canvas> </div> </div>
            </div>
            <div class="chart-container">
                <h3>Est. Annual Income by Holding</h3>
                <div class="chart-wrapper">
                    <canvas id="dividendChart"></canvas>
                </div>
            </div>
        </div>
        <div class="main-content">
            <div class="add-investment card-panel">
				<div class="investment-group-header" onclick="toggleAddForm()" style="margin: -25px -25px 20px -25px; border-radius: 15px 15px 0 0; border-left-color: #27ae60; width: calc(100% + 50px);">
					<div class="group-summary">
                        <div class="group-title">Add New Investment <span class="account-badge" style="background: #27ae60;">Form</span></div>
                    </div>
					<span class="toggle-icon" id="addFormToggleIcon">&#9658;</span>
				</div>
				<div id="addFormContent" style="display: none;">
                    <div class="form-group">
                        <label for="transactionType">Transaction Type</label>
                        <select id="transactionType" name="transactionType" onchange="toggleTransactionFields()" required>
                            <option value="BUY">BUY</option>
                            <option value="SELL">SELL</option>
                            <option value="DIVIDEND">DIVIDEND</option>
                            <option value="DEPOSIT">DEPOSIT</option>
                            <option value="WITHDRAWAL">WITHDRAWAL</option>
                        </select>
                    </div>
                    <div class="form-group"> <label for="transactionDate">Transaction Date</label> <input type="date" id="transactionDate" name="transactionDate" required> </div>
					<div class="form-group transaction-field"> <label for="symbol">Symbol</label> <input type="text" id="symbol" name="symbol" placeholder="e.g., AAPL, TSLA" oninput="validateSymbol()" required> <span id="symbolValidationStatus"></span> </div>
					<div class="form-group transaction-field"> <label for="name">Company Name</label> <input type="text" id="name" name="name" placeholder="e.g., Apple Inc." > </div>
                    <!-- FIX: ADDED HIDDEN INPUT FOR INVESTMENT TYPE -->
                    <input type="hidden" id="type" value="Stock">
                    <!-- END FIX -->
					<div class="form-group"> <label for="accountType">Account Type</label> <select id="accountType" name="accountType" onchange="handleAccountTypeChange()" required> <option value="">Select Account</option> <option value="Regular Brokerage">Regular Brokerage</option> <option value="Roth IRA">Roth IRA</option> <option value="401(k)">401(k)</option> <option value="529 College Saving">529 College Saving</option> <option value="Yahoo Finance">Yahoo Finance</option> </select> </div>
					<div class="form-group" id="fundingSourceGroup" style="display:none;">
                        <label for="fundingSource">Fund Purchase From</label>
                        <select id="fundingSource" name="fundingSource" required>
                            <!-- Options will be populated dynamically -->
                        </select>
                    </div>
					<div class="form-group"> <label for="platform">Platform</label>
                        <select id="platform" name="platform" required>
                            <option value="">Select Platform</option>
                            <option value="Fidelity">Fidelity</option>
                            <option value="Vanguard">Vanguard</option>
                            <option value="Charles Schwab">Charles Schwab</option>
                            <option value="Merrill Edge">Merrill Edge</option>
                            <option valuef="E*TRADE">E*TRADE</option>
                            <option value="Other">Other</option>
                        </select>
                    </div>
					<div class="form-group transaction-field buy-sell-field"> <label for="shares">Number of Shares</label> <input type="number" id="shares" name="shares" step="any" min="0" placeholder="100" oninput="updateTransactionFields('shares')" required> </div>
					<div class="form-group transaction-field buy-sell-field"> <label for="price">Price per Share</label> <input type="number" id="price" name="price" step="any" min="0" placeholder="150.00" oninput="updateTransactionFields('price')" required> </div>
                    <div class="form-group transaction-field buy-sell-field">
                        <label for="totalAmount">Total Amount ($)</label>
                        <input type="number" id="totalAmount" name="totalAmount" step="any" min="0" placeholder="0.00" oninput="updateTransactionFields('amount')">
                    </div>
                    <div class="form-group cash-field" style="display:none;">
                        <label for="amount">Amount ($)</label>
                        <input type="number" id="amount" name="amount" step="any" min="0" placeholder="1000.00">
                    </div>
                    <div class="form-group transaction-field">
                        <label for="dividend">Est. Annual Dividend/Share</label>
                        <input type="number" id="dividend" name="dividend" step="any" min="0" placeholder="0.00">
                    </div>
                    <button type="submit" class="btn" onclick="logTransaction()">Log Transaction</button>
                    <hr style="margin: 15px 0; border-color: var(--border-color);">
                    <div class="form-group">
                        <button class="btn btn-secondary" onclick="openRecurringPurchaseModal()" style="background: linear-gradient(45deg, #2c3e50, #34495e);">Set Up Recurring Purchase</button>
                    </div>
                </div>
            </div>
            <div class="investments-list card-panel">
                <div class="tabs-nav">
                    <button class="tab-link active" onclick="showTab('investments')">Positions</button>
                    <button class="tab-link" onclick="showTab('transactions')">All Transactions</button>
                </div>

                <div id="investmentsTab" class="tab-content active">
                    <div class="controls-bar">
                        <div class="form-group">
                            <label for="sortOptions">Sort By:</label>
                            <select id="sortOptions">
                                <option value="default">Default (Cash first, then Value)</option>
                                <option value="valueDesc">Value (High to Low)</option>
                                <option value="valueAsc">Value (Low to High)</option>
                                <option value="gainDesc">Unrealized G/L (High to Low)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="filterPlatform">Platform Filter:</label>
                            <select id="filterPlatform">
                                <option value="all">All Platforms</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="searchInput">Search Symbol/Name:</label>
                            <input type="text" id="searchInput" placeholder="e.g., VOO">
                        </div>
                        <button class="btn btn-secondary" onclick="triggerCsvImport()" style="background: #3498db; width: auto; min-width: 120px;">Import CSV</button>
                        <input type="file" id="csvFileInput" accept=".csv" style="display:none;">
                        <button class="btn btn-secondary" onclick="exportCSV()" style="background: #2980b9; width: auto; min-width: 120px;">Export CSV</button>
                        <button class="btn btn-danger" id="clearAllDataBtn" onclick="clearAllData()" style="width: auto; min-width: 120px; background: #e74c3c;">Clear All Data</button>
                    </div>
                    <div id="investmentsList" class="investment-groups-container">
                        <!-- Investment groups will be rendered here -->
                    </div>
                </div>
                
                <div id="transactionsTab" class="tab-content">
                    <div id="allTransactionsList">
                        <!-- All transactions table will be rendered here -->
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="countdown-timer" class="countdown-timer"></div>
</body>
</html>
